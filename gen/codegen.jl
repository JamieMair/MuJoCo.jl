import Graphs


const value_type_mapping = Dict{String, Symbol}(
    "char"=>:Cchar,
    "int"=>:Cint,
    "long"=>:Int64,
    "float"=>:Float32,
    "double"=>:Float64,
    "void"=>:Cvoid,
    "unsigned int"=>:Cuint,
    "uintptr_t"=>:Csize_t,
    "size_t"=>:Csize_t
)

parse_type(f::ValueType) = f.name
parse_type(f::PointerType) = parse_type(f.inner_type)
parse_type(f::ArrayType) = parse_type(f.inner_type)
parse_type(f::StructFieldDecl) = parse_type(f.type)
parse_type(f) = nothing


function sort_structs(structs::AbstractArray{StructDecl})
    graph = Graphs.DiGraph(length(structs), 0)
    struct_map = Dict(
        (s.name=>i for (i, s) in enumerate(structs))...
    )
    skipped_lookups = Set{String}()
    for (i, s) in enumerate(structs)
        for f in s.fields
            p = parse_type(f)
            if !isnothing(p) && !haskey(value_type_mapping, p)
                # Name of struct
                if haskey(struct_map, p)
                    j = struct_map[p]
                    Graphs.add_edge!(graph, i, j)
                else
                    push!(skipped_lookups, p)
                end
            end
        end
    end

    for skipped in skipped_lookups
        @info "Skipped $skipped in struct lookup. Must be defined elsewhere."
    end

    sorted_ids = Graphs.topological_sort(graph)
    
    return reverse(structs[sorted_ids])
end


function declare(enum::EnumDecl)
    pair_values = [(k, v) for (k, v) in enum.values]
    sort!(pair_values; by=(x->x[2]))
    body = Expr(:block, (Expr(:(=), Symbol(k), v) for (k, v) in pair_values)...)
    enum_name = Expr(:(::), Symbol(enum.name), :Cint)
    Expr(:macrocall, Symbol("@cenum"), LineNumberNode(1), enum_name, body)
end

function equivalent_type(type)
    return :UNKNOWN
end
function equivalent_type(type::ValueType)
    if haskey(value_type_mapping, type.name)
        return value_type_mapping[type.name]
    end

    if !startswith(type.name, "mj")
        @show type.name
    end

    return Symbol(type.name)
end
function equivalent_type(type::CAnonymousType)
    return :ANON
end
function equivalent_type(type::PointerType)
    return Expr(:curly, :Ptr, equivalent_type(type.inner_type))
end
function equivalent_type(type::ArrayType)
    return Expr(:curly, :NTuple, reduce(*, type.extents), equivalent_type(type.inner_type))
end
function declare(struct_field::StructFieldDecl)
    # Disallow reserved names
    disallowed_names = Set(("global",))
    name = if struct_field.name in disallowed_names
        "_$(struct_field.name)"
    else
        struct_field.name
    end

    return Expr(:(::), Symbol(name), equivalent_type(struct_field.type))
end

function declare(s::StructDecl)
    body = Expr(:block, (declare(f) for f in s.fields)...)
    Expr(:struct, false, Symbol(s.name), body)
end

const anon_struct_number = Ref(0)
function declare(s::AnonymousStructDecl)
    struct_num = anon_struct_number[] + 1
    anon_struct_number[] = struct_num
    body = Expr(:block, (declare(f) for f in s.fields)...)
    return Expr(:struct, Symbol("AnonStruct$(struct_num)"), body)
end
function declare(s::AnonymousUnionDecl)
    return :UNKNOWNANONDECL
end


function declare_file(filepath, contents; exports = String[], packages = String[])
    remove_line_comments = r"#=.*=#\s*"
    open(filepath, "w") do io
        println(io, """
        # This file is automatically generated and should not be manually edited.
        """)

        for p in packages
            println(io, "using $p")
        end
        println(io)
        
        for c in contents
            expr_unfiltered = string(declare(c))
            expr = replace(expr_unfiltered, remove_line_comments=>"")

            println(io, expr)
            println(io)
        end

        if length(exports) > 0
            print(io, "export ")
            join(io, exports, ", ")
        end
    end
end