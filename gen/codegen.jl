const value_type_mapping = Dict{String, Symbol}(
    "char"=>:Cchar,
    "int"=>:Cint,
    "long"=>:Int64,
    "float"=>:Float32,
    "double"=>:Float64,
    "void"=>:Cvoid,
    "unsigned int"=>:Cuint,
    "uintptr_t"=>:Csize_t,
    "size_t"=>:Csize_t
)

function declare(enum::EnumDecl)
    pair_values = [(k, v) for (k, v) in enum.values]
    sort!(pair_values; by=(x->x[2]))
    body = Expr(:block, (Expr(:(=), Symbol(k), v) for (k, v) in pair_values)...)
    enum_name = Expr(:(::), Symbol(enum.name), :Cint)
    Expr(:macrocall, Symbol("@cenum"), LineNumberNode(1), enum_name, body)
end

function equivalent_type(type)
    return :UNKNOWN
end
function equivalent_type(type::ValueType)
    if haskey(value_type_mapping, type.name)
        return value_type_mapping[type.name]
    end

    if !startswith(type.name, "mj")
        @show type.name
    end

    return Symbol(type.name)
end
function equivalent_type(type::CAnonymousType)
    return :ANON
end
function equivalent_type(type::PointerType)
    return Expr(:curly, :Ptr, equivalent_type(type.inner_type))
end
function equivalent_type(type::ArrayType)
    return Expr(:curly, :NTuple, reduce(*, type.extents), equivalent_type(type.inner_type))
end
function declare(struct_field::StructFieldDecl)
    return Expr(:(::), Symbol(struct_field.name), equivalent_type(struct_field.type))
end

function declare(s::StructDecl)
    body = Expr(:block, (declare(f) for f in s.fields)...)
    Expr(:struct, false, Symbol(s.name), body)
end

const anon_struct_number = Ref(0)
function declare(s::AnonymousStructDecl)
    struct_num = anon_struct_number[] + 1
    anon_struct_number[] = struct_num
    body = Expr(:block, (declare(f) for f in s.fields)...)
    return Expr(:struct, Symbol("AnonStruct$(struct_num)"), body)
end
function declare(s::AnonymousUnionDecl)
    return :UNKNOWNANONDECL
end


function declare_file(filepath, contents; exports = String[], packages = String[])
    remove_line_comments = r"#=.*=#\s*"
    open(filepath, "w") do io
        println(io, """
        # This file is automatically generated and should not be manually edited.
        """)

        for p in packages
            println(io, "using $p")
        end
        println(io)
        
        for c in contents
            expr_unfiltered = string(declare(c))
            expr = replace(expr_unfiltered, remove_line_comments=>"")

            println(io, expr)
            println(io)
        end

        if length(exports) > 0
            print(io, "export ")
            join(io, exports, ", ")
        end
    end
end