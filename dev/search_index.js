var documenterSearchIndex = {"docs":
[{"location":"contributing/developing/#Contributing-to-the-Package","page":"Contributing to the Package","title":"Contributing to the Package","text":"","category":"section"},{"location":"contributing/developing/","page":"Contributing to the Package","title":"Contributing to the Package","text":"The majority of the files in this package are auto-generated by a script which parses the original MuJoCo source code, found in gen/generator.jl.","category":"page"},{"location":"contributing/developing/","page":"Contributing to the Package","title":"Contributing to the Package","text":"This script performs the following operations:","category":"page"},{"location":"contributing/developing/","page":"Contributing to the Package","title":"Contributing to the Package","text":"Generates the C bindings using Clang.jl, based on the compiled MuJoCo_jll package.\nScrapes the introspect Python module found in the mujoco source code, and parses these files to extract docstrings and types.\nThe C bindings are then cleaned to remove non-compiling generated expressions (due to the C macros)\nThe documentation from step 2 is then injected to all the Julia generated methods and structs.\nNative Julia wrappers for the C level structs are written based on the MuJoCo C structs to make them easier to use in high-level Julia (including adding Garbage Collection)\nNext, the Named Access API is then automatically generated  based on the X and XGROUP macros in the original source code (mujoco/include/mujoco/mjxmacro.h)\nFinally, we parse the file at mujoco/python/mujoco/functions.cc to re-write some of the MuJoCo functions in the same way that the Python bindings do to ensure error checking when passing array objects to these functions. These checks will make sure the arrays of the correct size and type, even checking to make sure the arrays are stored in row-major.","category":"page"},{"location":"contributing/developing/","page":"Contributing to the Package","title":"Contributing to the Package","text":"All the files generated by this process contain a warning to not modify the files. If you would like to change something or add it to one of these files, modify the gen/generator.jl script to include these. If the source code does not need to be automatically generated, consider adding a file or code directly into the src directory.","category":"page"},{"location":"contributing/developing/","page":"Contributing to the Package","title":"Contributing to the Package","text":"warning: Warning\nThe source code under the gen folder is currently in need of a major refactor to make it more maintainable in the future. This refactoring work is expected to take place soon, but will not delay core use of the package.","category":"page"},{"location":"examples/cartpole_balance/#Balancing-a-Cart-Pole","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"For our first example, we'll simulate a cart-pole system balancing its pendulum in the upright equilibrium using a Linear Quadratic Regulator (LQR). Simulating controllers which balance and stabilise robotic systems is a common use-case for MuJoCo, so this is a good starting point. There are plenty of different ways to design stabilising controllers for the cart-pole system (eg: PID, MPC, reinforcement learning, etc...). Feel free to extend this example with your own controllers and play around with it!","category":"page"},{"location":"examples/cartpole_balance/#Loading-a-model","page":"Balancing a Cart-Pole","title":"Loading a model","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Our first step is to load a MuJoCo model of the cart-pole system. You can find a copy of the standard cartpole.xml file used by DeepMind here. ","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"using MuJoCo\n\nmodel = load_model(\"cartpole.xml\")\ndata = init_data(model)\n\nprintln(\"Initial position: \", data.qpos)\nprintln(\"Initial velocity: \", data.qvel)","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"The system starts off with zero velocity, at the origin (data.qpos[1] == 0) and with the pendulum perfectly upright (data.qpos[1] == 0). This is the state we'll want to keep it in with our controller.","category":"page"},{"location":"examples/cartpole_balance/#A-quick-review-of-LQR","page":"Balancing a Cart-Pole","title":"A quick review of LQR","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"There are many textbooks, tutorials, and course notes describing LQRs in considerable depth (see here for an example). We'll give a brief, high-level recap here. Suppose you have a system with state vector x (eg: joint positions and velocities) and some control inputs u (eg: forces and/or torques). We often write the system dynamics as x_t+1 = f(x_t u_t), where the function f describes how the states x evolve at each time-step t.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"In linear control design, our job is often to figure out what the control inputs u_t should be to keep the system at some desired set-point (x^* u^*). For our cart-pole, we want it to be stationary and upright at the origin, so (x^* u^*) = (zeros(4) 0). Let's look at a linear approximation of the system about this set-point:","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"delta x_t+1 = A delta x_t + B delta u_t","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Here, we've defined delta x_t = x_t - x^* and delta u_t = u_t - u^* as the differences between the current and desired states and controls (respectively). The matrices AB defining the linear model are the Jacobians","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"A = fracpartial fpartial x quad B = fracpartial fpartial u","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Our task is to design a controller that will keep delta x_t and delta u_t small. In particular, we can define a cost-function that we want our controller to optimise. For an LQR, we define a quadratic cost","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"J(delta x_t delta u_t) = delta x_t^top Q delta x_t + delta u_t^top R delta u_t","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"to be minimised, where QR are positive-definite matrices of our choosing. With a little bit of matrix algebra and vector calculus based on the Bellman equation, it turns out that the optimal control law is u_t = -K x_t where ","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"K = (R + B^top P B)^-1 B^top P A\nP = A^top P A + Q - A^top P B (R + B^top P B)^-1 B^top P A","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Thankfully, this last equation is a well-studied Riccati equation, so we can use packages like MatrixEquations.jl or ControlSystems.jl to solve it for us.","category":"page"},{"location":"examples/cartpole_balance/#Linearising-the-dynamics","page":"Balancing a Cart-Pole","title":"Linearising the dynamics","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"We can use the underlying C API for MuJoCo to easily linearise the dynamics for our cart-pole system. The function mjd_transitionFD numerically computes the A and B matrices with a finite difference method through the MuJoCo simulator.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"# Number of states and controlled inputs\nnx = 2*model.nv\nnu = model.nu\n\n# Finite-difference parameters\nϵ = 1e-6\ncentred = true\n\n# Compute the Jacobians\nA = mj_zeros(nx, nx)\nB = mj_zeros(nx, nu)\nmjd_transitionFD(model, data, ϵ, centred, A, B, nothing, nothing)\n@show A, B\nnothing #hide","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Note the use of mj_zeros to initialise AB. See Row vs. Column-Major Arrays for more details.","category":"page"},{"location":"examples/cartpole_balance/#Designing-a-controller","page":"Balancing a Cart-Pole","title":"Designing a controller","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Now that we have our linear model, all we need to do is compute our LQR gain matrix K based on some cost-function with weights QR. The state vector for our cart-pole system is x = [cart_position, pole_angle, cart_velocity, pole_velocity]. We'll choose QR to heavily penalise any movement of the pole away from vertical. This may mean the cart slides around a little bit, but if our goal is to keep the pole upright this is fine.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"using LinearAlgebra\n\nQ = diagm([1, 10, 1, 5]) # Weights for the state vector\nR = diagm([1])           # Weights for the controls\nnothing # hide","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"To compute K, we could directly use the lqr function provided in ControlSystemsBase.jl with K = lqr(A,B,Q,R). For those who don't want to load the rather large control systems package, we can directly use ared from MatrixEquations.jl, which is what lqr calls under the hood.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"using MatrixEquations\n\nS = zeros(nx, nu)\n_, _, K, _ = ared(A,B,R,Q,S)\n@show K","category":"page"},{"location":"examples/cartpole_balance/#Simulate-and-visualise","page":"Balancing a Cart-Pole","title":"Simulate and visualise","text":"","category":"section"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"After all that, we now have a stabilising controller for our cart-pole system! Let's test it out with the visualiser. First, we'll need a controller function that takes in the MuJoCo model and data structs and sets the control variables.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"function lqr_balance!(m::Model, d::Data)\n    state = vcat(d.qpos, d.qvel)\n    d.ctrl .= -K * state\n    nothing\nend\nnothing # hide","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"warning: Performance Tip\nThis function captures non-const global variables and will take a performance hit (see Performance Tips) for more details. To remedy the performance hit, one can use functors instead, as described at the end of the Humanoid LQR example.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"Now we can visualise the model and see how it goes.","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"init_visualiser()\nvisualise!(model, data; controller=lqr_balance!)","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"(Image: )","category":"page"},{"location":"examples/cartpole_balance/","page":"Balancing a Cart-Pole","title":"Balancing a Cart-Pole","text":"When we apply small forces to the pole or the cart, the controller immediately responds to the perturbation and returns the system to its equilibrium position. If the force is big enough, the system will become unstable and the pole will fall down. Feel free to play around with the weights in QR to see their effect on the system too!","category":"page"},{"location":"intro/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"intro/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"To install MuJoCo.jl, simply run the following code in a Julia REPL:","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"import Pkg\nPkg.add(\"MuJoCo.jl\")","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"This will download and install the package, along with the underlying C library. We highly recommend activating a project to manage dependencies - see the docs for more information.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Once installed, you can load the package in the REPL just like any other Julia package. To use the visualiser and see your MuJoCo models in action, you will need to install some additional dependencies with","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"using MuJoCo\ninstall_visualiser()","category":"page"},{"location":"intro/getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"You should now be able to load in and play around with any MuJoCo model of your choosing. You can create your own MuJoCo models with the MJCF modelling language, but for now we'll load in a model of a humanoid for demonstration purposes.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"using MuJoCo\n\nmodel, data = MuJoCo.sample_model_and_data()\n@show typeof(model), typeof(data)","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"The Model and Data types encode all the information required to simulate a model in MuJoCo, and are wrappers of the mjModel and mjData structs in the C API, respectively. We can directly access any data from these structs:","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"Simulation timestep: \", model.opt.timestep)\nprintln(\"Positions of joints: \", data.qpos)","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can also directly read and write from/to these fields. However, we cannot directly overwrite any arrays. Instead, we can use Julia's broadcasting to set values as we see fit. Let's write a function that inputs random control torques to the humanoid's joints.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"function random_controller!(m::Model, d::Data)\n    nu = m.nu\n    d.ctrl .= 2*rand(nu) .- 1\n    return nothing\nend","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can now simulate motion of the humanoid under this control scheme. Let's simulate over 100 time-steps.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"for t in 1:100\n    random_controller!(model, data)\n    step!(model, data)\nend","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"At each time-step, random_controller! sets the control signal to some random value, and step! calls the MuJoCo physics engine to simulate the response of the system. step! directly modifies the data struct. For example, looking at data.qpos again shows that the joints have all moved.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"New joint positions: \", data.qpos)","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"After finishing our initial simulations, we can re-set the model back to its starting position by calling mj_resetData, one of the underlying C library functions. Any of the functions listed in the LibMuJoCo Index can be used just as they are described in the MuJoCo documentation.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"mj_resetData(model, data)\nprintln(\"Reset joint positions: \", data.qpos)","category":"page"},{"location":"intro/getting_started/#Visualising-a-Model","page":"Getting Started","title":"Visualising a Model","text":"","category":"section"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Of course, the best way to understand what a MuJoCo model is doing is to visualise it. To use the visualiser, simply initialise it and call visualise!. We can test our controller by passing in our function via the controller keyword.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"init_visualiser()\nvisualise!(model, data, controller=random_controller!)","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Press F1 for help after running the visualiser to print the available options in a terminal. Some of the most interesting are:","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Press CTRL+RightArrow (or CMD for Mac) to cycle between the passive dynamics and the controlled motion\nPress SPACE to pause/unpause\nDouble-click on an object select it\nCTRL+RightClick and drag to apply a force\nPress Backspace to reset the model\nPress ESC to exit the simulation","category":"page"},{"location":"intro/getting_started/#Visualising-a-Trajectory","page":"Getting Started","title":"Visualising a Trajectory","text":"","category":"section"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Sometimes it will be more convenient to simulate the motion of a MuJoCo model and save its response for later analysis. The visualiser includes a Trajectory mode to enable this. Let's reset! our humanoid model and set its initial height to 2 metres above the ground.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"reset!(model, data)\ndata.qpos[3] = 2\nforward!(model, data) # Propagate the physics forward ","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"The motion of every MuJoCo model can be described by some physical state vector consisting of the positions and velocities of its components, and the state of its actuators. We have included get_physics_state and set_physics_state! to allow users to record (and set) the states of a model during simulation. Let's simulate our humanoid for another 100 timesteps and record its state.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"tmax = 400\nnx = model.nq + model.nv + model.na # State vector dimension\nstates = zeros(nx, tmax)\nfor t in 1:tmax\n    states[:,t] = get_physics_state(model, data)\n    step!(model, data)\nend","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"We'll also go back and save the humanoid states under our random controller. ","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"reset!(model, data)\nctrl_states = zeros(nx, tmax)\nfor t in 1:tmax\n    ctrl_states[:,t] = get_physics_state(model, data)\n    random_controller!(model, data)\n    step!(model, data)\nend","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can now play back either the passive or controlled humanoid motion whenever we like using the Trajectory mode in the visualiser. This allows us to re-wind the simulation, simulate it backwards, skip forward/backwards a few frames, and add some cool visualisation features.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"visualise!(model, data, trajectories = [states, ctrl_states])","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"You might find the following tips useful:","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Press CTRL+RightArrow (or CMD for Mac) to cycle between the passive dynamics and the saved trajectories\nPress F1 to see the new Trajectory mode button and mouse options, including:\nPress UP or DOWN to cycle between trajectories\nPRESS CTRL+R for reverse mode\nPress CTRL+B to turn burst-mode on\nPress CTRL+D to add a doppler shift","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"We strongly recommend saving trajectories for later visualisation if you're simulating any particularly complicated tasks in MuJoCo. You can start up the visualiser with all three of the passive dynamics, controlled dynamics, and saved trajectories. See visualise! for details.","category":"page"},{"location":"intro/getting_started/","page":"Getting Started","title":"Getting Started","text":"Happy visualising!","category":"page"},{"location":"examples/humanoid_lqr/#Humanoid-LQR","page":"Humanoid LQR","title":"Humanoid LQR","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Our second example is a translation of DeepMind's LQR tutorial into Julia. The aim is to balance a humanoid on one leg with a Linear Quadratic Regulator (LQR). Users familiar with MuJoCo's python bindings might find it useful to compare this example to the DeepMind tutorial to see the similarities and differences with MuJoCo.jl.","category":"page"},{"location":"examples/humanoid_lqr/#The-humanoid-model","page":"Humanoid LQR","title":"The humanoid model","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Let's start by having a look at the humanoid model shipped with MuJoCo. You can find a copy of the humanoid.xml file here, or locally in the directory given by running example_model_files_directory.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"using MuJoCo\n\nmodel = load_model(joinpath(example_model_files_directory(), \"humanoid.xml\"))\ndata = init_data(model)\nnothing # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"The model comes shipped with three different \"keyframes\" defining particular starting poses of the humanoid. You can inspect each one by re-setting the model to a specific keyframe with resetkey! and running visualise!.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"init_visualiser()\n\nfor i in 1:3\n    resetkey!(model, data, i)\n    visualise!(model, data)\nend","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"@html_str \"\"\"<p float=\"left\"> <img src=$(joinpath(Main.buildpath, \"images/humanoid_kf_squat.gif\")) width=\"400\" /> <img src=$(joinpath(Main.buildpath, \"images/humanoid_kf_leg.gif\")) width=\"400\" /> <img src=$(joinpath(Main.buildpath, \"images/humanoid_kf_stand.gif\")) width=\"400\" /> </p>\"\"\" # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"None of these initial states are stable. In this example, we'll focus on designing a controller for the second keyframe to get the humanoid to stand and balance on one leg. ","category":"page"},{"location":"examples/humanoid_lqr/#Computing-the-control-set-point","page":"Humanoid LQR","title":"Computing the control set-point","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"To design our linear controller, we'll need a set-point (x^* u^*) about which to stabilise the system. We already have x^*, since the desired state is just the starting position of the humanoid in keyframe 2. To find the control inputs required to hold the humanoid in this position, we'll use inverse dynamics via MuJoCo's mj_inverse. If we set all joint accelerations to zero, mj_inverse computes the forces required to hold the model in a given configuration. Let's try it out.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"# Reset to desired keyframe\nkeyframe = 2\nresetkey!(model, data, keyframe)\n\n# Propagate derived quantities\nmj_forward(model, data)\n# Set joint accelerations to 0\ndata.qacc .= 0\n\n# Inspect forces from inverse dynamics\nmj_inverse(model, data)\nprintln(\"Required control: \", data.qfrc_inverse)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Unfortunately for us, things are not so simple. data.qfrc_inverse stores the calculated forces that are required to achieve the desired joint acceleration. Looking at its output, we see that the third element is a large value. This corresponds to an unphysical vertical force due to the humanoid starting slightly above the ground. The simulator has been forced to introduce this impossible force to meet the requirement that data.qacc == 0.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We can remove this unphysical force by slightly tweaking the starting height of the model. Let's examine how this large force changes when we move the humanoid up/down from its starting position. We will examine the range of heights from pm 1mm. Note that all heights are all measured in metres.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"using CairoMakie\nusing LinearAlgebra\n\nheights = LinRange(-0.001, 0.001, 2001) # -1mm to +1mm\n# Map each height to the corresponding high force output\nu_vert = map(heights) do h\n    # Set model in position with qacc == 0\n    resetkey!(model, data, keyframe)\n    mj_forward(model, data)\n    data.qacc .= 0\n\n    # Offset the height and check required vertical forces\n    data.qpos[3] += h\n    mj_inverse(model, data)\n    return data.qfrc_inverse[3] # 3 -> z-force\nend\n\n# Find height corresponding to minimum fictitious force (best offset)\nheight = heights[argmin(abs.(u_vert))]\nheight_mm = height*1000\nheights_mm = heights .* 1000\n\n# Compare force to weight of humanoid\nweight = sum(model.body_mass) * norm(model.opt.gravity)\n\nfig = Figure(resolution=(500,300))\nax = Axis(fig[1,1], xlabel=\"Vertical offset (mm)\", ylabel=\"Vertical force (N)\")\nlines!(ax, heights_mm, u_vert, label=\"Vertical force\")\nlines!(ax, heights_mm, weight*ones(length(heights)), linestyle=:dash, label=\"Weight\")\nlines!(ax, [height_mm, height_mm], [minimum(u_vert), maximum(u_vert)], linestyle=:dash)\naxislegend(ax,position=:rb)\nsave(\"humanoid_force_offset.svg\",fig) # hide\nnothing #hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"(Image: )","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"As we lift the humanoid upwards, the vertical force increases until it exactly balances the weight of the humanoid. This is the force required to keep the accelerations zero while the model is in the air. Pushing the humanoid down, however, requires an increasingly negative vertical force to explain the fact that its foot is penetrating the floor but data.qacc == 0. At a height of approximately -05mm the humanoid's foot is just resting on the floor and all forces can be accounted for by internal torques only. This is the case we're interested in.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Let's now take our best-choice offset and save the humanoid's position and forces (from inverse dynamics) to define our set point. Our position set-point is just data.qpos after changing the height.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"resetkey!(model, data, keyframe)\nmj_forward(model, data)\ndata.qacc .= 0\ndata.qpos[3] += height\nqpos0 = copy(data.qpos)\nprintln(qpos0)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We can compute the control set-point by propagating the required forces through the actuator dynamics. For the simple linear motors in our humanoid robot, we can directly use data.actuator_moment as the Jacobian of data.qfrc_inverse with respect to data.ctrl.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"mj_inverse(model, data)\nqfrc0 = copy(data.qfrc_inverse)\n\nM_act = data.actuator_moment\nctrl0 = pinv(M_act)' * qfrc0\nprintln(ctrl0)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"As a sanity check, let's verify that these control inputs actually give us the right forces.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"data.ctrl .= ctrl0\nmj_forward(model, data)\nqfrc_test = data.qfrc_actuator\nprintln(\"Desired forces: \", qfrc0)\nprintln(\"Actual forces:  \", qfrc_test)\nprintln(\"Joint forces equal? \", all((qfrc_test .≈ qfrc0)[7:end]))","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"The actuator forces are approximately equal to the desired forces qfrc0 for all joints in the humanoid. The first six elements correspond to forces on the \"root joint\" (the free body of the humanoid). There is still a slight mismatch here, but it is minor. Let's also have a look at how the model behaves if we start it exactly at our set point.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"reset!(model, data)\ndata.qpos .= qpos0\ndata.ctrl .= ctrl0\nvisualise!(model, data)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"(Image: )","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"The humanoid still falls over because we are trying to stabilise the system at an unstable equilibrium point, and the control set-point ctrl0 is only an approximation. Even if we had found the exact controls to hold the system in qpos0, any slight perturbation would cause the humanoid to fall over. We therefore need a controller.","category":"page"},{"location":"examples/humanoid_lqr/#Designing-the-LQR-cost","page":"Humanoid LQR","title":"Designing the LQR cost","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"See A quick review of LQR if you're in need of a refresher on linear quadratic regulators.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Now that we have our set point to stabilise, we'll need to design the LQR weight matrices QR to encourage the system to remain balanced. Let's start by setting R equal to the identity matrix I and defining some useful variables.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"nu = model.nu # number of actuators/controls\nnv = model.nv # number of degrees of freedom\nR = Matrix{Float64}(I, nu, nu)\nnothing #hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We'll construct the Q matrix in two parts: one component to encourage the humanoid's centre of mass (CoM) to remain above its foot (helps with stability), and another component to keep the joints close to their original configuration qpos0.","category":"page"},{"location":"examples/humanoid_lqr/#CoM-balancing-cost","page":"Humanoid LQR","title":"CoM balancing cost","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Much like the Python bindings, MuJoCo.jl includes a number of useful functions to isolate and work with different parts of a MuJoCo model. Let's extract references for the torso and left foot and have a look at one of them.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"import MuJoCo as MJ\n\ntorso = MJ.body(model, \"torso\")\nleft_foot = MJ.body(model, \"foot_left\")","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"One way to keep the CoM over the left foot is to design Q from the difference between the CoM and left-foot Jacobians. MuJoCo's C API comes with a number of very useful functions for computing Jacobians.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"# Get Jacobian for torso CoM\nreset!(model, data)\ndata.qpos .= qpos0\nforward!(model, data)\njac_com = mj_zeros(3, nv)\nmj_jacSubtreeCom(model, data, jac_com, torso.id)\n\n# Get (left) foot Jacobian for balancing\njac_foot = mj_zeros(3, nv)\nmj_jacBodyCom(model, data, jac_foot, nothing, left_foot.id)\n\n# Design Q-matrix to balance CoM over foot\njac_diff = jac_com .- jac_foot\nQbalance = jac_diff' * jac_diff\nprintln(Qbalance) #hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Note the use of mj_zeros to initialise the Jacobians, as outlined in Row vs. Column-Major Arrays.","category":"page"},{"location":"examples/humanoid_lqr/#Joint-deviation-cost","page":"Humanoid LQR","title":"Joint deviation cost","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We will also want to add a cost on the joints deviating from the desired position qpos0. However, different parts of the humanoid will need to be treated differently. In particular:","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"The \"free joints\" (i.e: CoM position) should have no cost on them here, since we've already defined Qbalance to take care of them.\nThe joints in the left leg and lower abdomen should be held close to their original values to keep the balancing leg in place\nOther joints, such as flailing limbs, should be allowed to move around more freely to maintain balance if the humanoid is perturbed.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Let's start by finding the array indices relevant to each set of joints. We'll leverage some of the nice features of the Named Access tools.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"# Get indices into relevant sets of joints.\nfree_dofs = 1:6\nbody_dofs = 7:nv\n\n# Get all the joints using a list comprehension. \n# We add one to the raw ID to get the Julia 1-based index of the joint.\nabdomen_dofs = [jnt.id+1 for jnt in MJ.joints(model) if occursin(\"abdomen\", jnt.name)]\nleft_leg_dofs = [jnt.id+1 for jnt in MJ.joints(model) if occursin(\"left\", jnt.name) && any(occursin(part, jnt.name) for part in (\"hip\", \"knee\", \"ankle\"))]\n\nbalance_dofs = vcat(abdomen_dofs, left_leg_dofs)\nother_dofs = setdiff(body_dofs, balance_dofs)\n\nprintln(\"Balance dofs: \", balance_dofs)\nprintln(\"Other dofs:   \", other_dofs)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We can now use these indices to construct the second part of the Q matrix.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"# Cost coefficients\nbalance_joint_cost = 3          # Joints can move a bit and still balance\nother_joint_cost   = 0.3        # Other joints can do whatever\n\n# Construct joint Q matrix\nQjoint = Matrix{Float64}(I, nv, nv)\nQjoint[free_dofs, free_dofs] *= 0\nQjoint[balance_dofs, balance_dofs] *= balance_joint_cost\nQjoint[other_dofs, other_dofs] *= other_joint_cost\nnothing #hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Putting this all together with Qbalance, we can construct our final Q matrix defining our LQR cost.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"balance_cost = 1000\n\nQpos = balance_cost*Qbalance + Qjoint\nQ = [Qpos zeros(nv,nv); zeros(nv, 2nv)]  + (1e-10) * I # Add ϵI for positive definite Q\nprintln(Q) # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Note that the balance_cost is quite large in comparison to balance_joint_cost because the units for the CoM position (metres) are typically \"larger\" than the units for joint angles (radians). Eg: if the CoM shifts by 01m, the humanoid will most likely fall over, but a 01radian change in a leg angle will probably be fine.","category":"page"},{"location":"examples/humanoid_lqr/#Computing-optimal-control-gains","page":"Humanoid LQR","title":"Computing optimal control gains","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"With both cost matrices defined, computing the optimal control gains is simply a matter of linearising the system dynamics about our chosen set-point (qpos0, ctrl0) and solving the LQR Riccati equations. We can follow the same process as our Balancing a Cart-Pole example. Let's start with the linear system Jacobians.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"# Initialise the model at our set point\nreset!(model, data)\ndata.ctrl .= ctrl0\ndata.qpos .= qpos0\n\n# Finite-difference parameters\nϵ = 1e-6\ncentred = true\n\n# Compute the Jacobians\nA = mj_zeros(2nv, 2nv)\nB = mj_zeros(2nv, nu)\nmjd_transitionFD(model, data, ϵ, centred, A, B, nothing, nothing)\n@show A, B","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Just like the cart-pole example, we'll directly use ared from MatrixEquations.jl to compute the LQR gain matrix K as a lightweight alternative to loading ControlSystemsCore.jl.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"using MatrixEquations\n\nS = zeros(2nv, nu)\n_, _, K, _ = ared(A,B,R,Q,S)","category":"page"},{"location":"examples/humanoid_lqr/#Testing-the-controller","page":"Humanoid LQR","title":"Testing the controller","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We are now ready to test our controller. First, we'll write a function to set the control gains on our humanoid at each simulation time-step. Note the use of mj_differentiatePos to compute the position error, which uses a finite difference to calculate the difference between two positions rather than subtracting qpos0 - data.qpos. This is necessary because orientations of free bodies in MuJoCo are represented by 4-element quaternions, but we are interested in differences between points in 3D space. This is why model.nq >= model.nv for all MuJoCo models.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"function humanoid_ctrl!(m::Model, d::Data)\n    Δq = zeros(m.nv)\n    mj_differentiatePos(m, Δq, 1, qpos0, d.qpos)\n\n    Δx = vcat(Δq, data.qvel)\n    data.ctrl .= ctrl0 .- K*Δx\n    nothing\nend\nnothing # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"warning: Performance Tip\nThis function captures non-const global variables and will take a performance hit (see Performance Tips) for more details. To remedy the performance hit, one can use functors instead, as described below.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Let's run the visualiser and test our controller by manually perturbing the humanoid. You can do this by double-clicking on a body to select it, then CTRL+RightClick and drag to apply a force.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"reset!(model, data)\ndata.qpos .= qpos0\nvisualise!(model, data, controller=humanoid_ctrl!)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"(Image: )","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"For small perturbations, our controller works just great! If you apply a large perturbation, you'll find that it's easy to de-stabilise the system and get the humanoid to fall over. This is to be expected from a simple LQR, but feel free to play around with the weight matrices to see if you can improve the robustness. In general, designing robust controllers for nonlinear systems is a difficult challenge and an open area of research in the control community.","category":"page"},{"location":"examples/humanoid_lqr/#Improve-performance-with-functors-and-cached-memory","page":"Humanoid LQR","title":"Improve performance with functors and cached memory","text":"","category":"section"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"A functor in Julia can be created by defining a struct to hold any variables that may be needed by a function, and defining the function itself when the struct is called. The struct will store all the variables that are used within the function that are not accessible from the input arguments. Our humanoid controller requires qpos0, ctrl0 and K. We also can reuse some memory in the form of Δq and Δx, so we can store this too inside the functor. Finally, we can store a matrix which holds the output of the K*Δx matrix multiplication.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"struct LQRHumanoidBalance{TQ,TC,TK,TDQ,TDX,TKDX}\n    qpos0::TQ\n    ctrl0::TC\n    K::TK\n    Δq::TDQ\n    Δx::TDX\n    KΔx::TKDX\nend\nnothing # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Notice that we are not restricting the types of the fields for clarity, however, the true type will be stored in the functors type information.","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Next, we must define the actual function body for the functor, which follows the same format as the previous controller:","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"function (functor::LQRHumanoidBalance)(model::Model, data::Data)\n    Δq = functor.Δq\n    mj_differentiatePos(model, Δq, 1, functor.qpos0, data.qpos)\n\n    Δx = functor.Δx\n    Δx[1:length(Δq)] .= Δq\n    Δx[(length(Δq)+1):end] .= data.qvel\n\n    KΔx = functor.KΔx\n    mul!(KΔx, functor.K, Δx)\n\n    data.ctrl .= functor.ctrl0 .- KΔx\n    nothing\nend\nnothing # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We can now create an instance of the functor, creating memory for the caches as well:","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"controller = LQRHumanoidBalance(\n    qpos0,\n    ctrl0,\n    K,\n    zeros(eltype(qpos0), model.nv), # Δq\n    zeros(eltype(qpos0), 2 * model.nv), # Δx\n    similar(ctrl0) # KΔx\n);\nnothing # hide","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"Now we can benchmark these two functions with BenchmarkTools.jl:","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"using BenchmarkTools\n@benchmark humanoid_ctrl!(model, data)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"@benchmark controller(model, data)","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"We can see that using a functor will give the best performance, at the cost of slightly more boilerplate code. ","category":"page"},{"location":"examples/humanoid_lqr/","page":"Humanoid LQR","title":"Humanoid LQR","text":"warning: Thread Safety\nThe use of the functor with local cache is not thread-safe, and a different functor must be used on each thread if running in parallel.","category":"page"},{"location":"library/libmujoco_index/#LibMuJoCo-Index","page":"Index","title":"LibMuJoCo Index","text":"","category":"section"},{"location":"library/libmujoco_index/","page":"Index","title":"Index","text":"Modules = [MuJoCo.LibMuJoCo]","category":"page"},{"location":"intro/overview/#Package-Overview","page":"Package Overview","title":"Package Overview","text":"","category":"section"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"This page is a work-in-progress and will be updated later","category":"page"},{"location":"intro/overview/#Models-with-Named-Access","page":"Package Overview","title":"Models with Named Access","text":"","category":"section"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"Many MuJoCo models attach names to the various joints and bodies that make up the model. It is often convenient to select a single part of the body and access information that may be contained in the larger arrays of model or data. MuJoCo.jl provides a few wrapper functions that allow us to access the underlying data.","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"As an example, let's investigate the torso of our humanoid. If you display the torso object in the REPL, you can see the fields that can be accessed in this object.","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"import MuJoCo as MJ\nmodel, data = MJ.sample_model_and_data();\nMJ.step!(model, data);\ntorso = MJ.body(data, \"torso\")","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"For example, torso.com will give you a 3-dimensional vector of the torso's centre of mass coordinates. ","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"torso.com","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"All other functions that generate a named wrapper around an object are documented in Named Access.","category":"page"},{"location":"intro/overview/#Row-vs.-Column-Major-Arrays","page":"Package Overview","title":"Row vs. Column-Major Arrays","text":"","category":"section"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"MuJoCo's underlying C API expects arrays to be row-major, while by default, all Julia arrays are column-major. However, Julia is high level enough to allow us to mimic the use of a row-major array by changing the type of the object, while keeping the array access patterns the same.","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"We have included mj_array and mj_zeros to make life easier when passing arrays to MuJoCo functions that directly mutate their arguments (eg: mjd_transitionFD and many others). An array initialised with either mj_array or mj_zeros will be a transpose(<:AbstractArray) and can be treated just the same as any other Julia array, but its memory will be accessed in row-major order. This means that the C API will correctly fill your arrays. Using these functions also still allows for performance specialisation based on the type. ","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"Let's look at an example. Suppose we want to compute a Jacobian for the humanoid's torso. There are model.nv degrees of freedom in the humanoid, and the torso's centre of mass is a 3-element vector. The Jacobian should therefore be a 3 x nv array. To ensure the order of elements is correct, we compute it with","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"jac_torso = MJ.mj_zeros(3, model.nv)\nMJ.mj_jacSubtreeCom(model, data, jac_torso, torso.id)\n@show jac_torso","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"warning: Beware the row-major order\nPassing a 3 x nv array directly to mj_jacSubtreeCom will not raise an error, but the order of elements in the Jacobian will be incorrect. For example:jac_torso_wrong = zeros(3, model.nv)\nMJ.mj_jacSubtreeCom(model, data, jac_torso_wrong, torso.id)\n@show jac_torso_wrong","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"More examples of working with matrices in MuJoCo are provided in Balancing a Cart-Pole and Humanoid LQR. For more information on row-major vs column major, see the Wikipedia page.","category":"page"},{"location":"intro/overview/#Wrapped-Functions","page":"Package Overview","title":"Wrapped Functions","text":"","category":"section"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"Similar to the Python API, we have wrapped several functions to allow the use of native Julia arrays. The majority of functions that take arrays as arguments have been wrapped to apply some basic bounds checks for the size of the arrays, along with a restriction of the type that can be passed in. ","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"Some of the function signatures have been changed to remove superfluous arguments that can be inferred by the data stored in the Julia arrays, for example:","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"println(methods(MJ.mju_add).ms[1])","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"vs the original:","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"println(methods(MJ.LibMuJoCo.mju_add).ms[1])","category":"page"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"The mj_ functions that have been wrapped are the defaults and can be found in src/function_constraints.jl and are documented in the MuJoCo API. If required, the original functions can be accessed inside the submodule LibMuJoCo.","category":"page"},{"location":"intro/overview/#Tips-and-Tricks","page":"Package Overview","title":"Tips and Tricks","text":"","category":"section"},{"location":"intro/overview/","page":"Package Overview","title":"Package Overview","text":"This library is a wrapper for MuJoCo. The documentation for MuJoCo is very comprehensive and should be referred to for any queries regarding usage of the simulator.\nAll functions or structs beginning with mj directly use the underlying C API.\nWhen writing code, keep a REPL open with a sample data and model object (such as generated in the above examples), and use tab-completition (double tap tab) to see what information is available. Check the MuJoCo docs or the LibMuJoCo Index to read the documentation for the parameters.","category":"page"},{"location":"library/api/#MuJoCo-API","page":"API","title":"MuJoCo API","text":"","category":"section"},{"location":"library/api/#MuJoCo","page":"API","title":"MuJoCo","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo]","category":"page"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo]","category":"page"},{"location":"library/api/#MuJoCo.Wrappers.Data","page":"API","title":"MuJoCo.Wrappers.Data","text":"mjData\n\nFields\n\nnstack: number of mjtNums that can fit in the arena+stack space\nnbuffer: size of main buffer in bytes\nnplugin: number of plugin instances\npstack: first available mjtNum address in stack\nparena: first available byte in arena\nmaxuse_stack: maximum stack allocation\nmaxuse_arena: maximum arena allocation\nmaxuse_con: maximum number of contacts\nmaxuse_efc: maximum number of scalar constraints\nwarning: warning statistics\ntimer: timer statistics\nsolver: solver statistics per iteration\nsolver_iter: number of solver iterations\nsolver_nnz: number of non-zeros in Hessian or efc_AR\nsolver_fwdinv: forward-inverse comparison: qfrc, efc\nnbodypair_broad: number of body pairs in collision according to the broad-phase\nnbodypair_narrow: number of body pairs actually in collision in the narrow-phase\nngeompair_mid: number of geom pairs in collision according to the mid-phase\nngeompair_narrow: number of geom pairs actually in collision in the narrow-phase\nne: number of equality constraints\nnf: number of friction constraints\nnefc: number of constraints\nnnzJ: number of non-zeros in constraint Jacobian\nncon: number of detected contacts\ntime: simulation time\nenergy: potential, kinetic energy\nbuffer: main buffer; all pointers point in it                (nbuffer bytes)\narena: arena+stack buffer                     (nstack*sizeof(mjtNum) bytes)\nqpos: position                                         (nq x 1)\nqvel: velocity                                         (nv x 1)\nact: actuator activation                              (na x 1)\nqacc_warmstart: acceleration used for warmstart                  (nv x 1)\nplugin_state: plugin state                                     (npluginstate x 1)\nctrl: control                                          (nu x 1)\nqfrc_applied: applied generalized force                        (nv x 1)\nxfrc_applied: applied Cartesian force/torque                   (nbody x 6)\nmocap_pos: positions of mocap bodies                        (nmocap x 3)\nmocap_quat: orientations of mocap bodies                     (nmocap x 4)\nqacc: acceleration                                     (nv x 1)\nact_dot: time-derivative of actuator activation           (na x 1)\nuserdata: user data, not touched by engine                 (nuserdata x 1)\nsensordata: sensor data array                                (nsensordata x 1)\nplugin: copy of m->plugin, required for deletion         (nplugin x 1)\nplugin_data: pointer to plugin-managed data structure         (nplugin x 1)\nxpos: Cartesian position of body frame                 (nbody x 3)\nxquat: Cartesian orientation of body frame              (nbody x 4)\nxmat: Cartesian orientation of body frame              (nbody x 9)\nxipos: Cartesian position of body com                   (nbody x 3)\nximat: Cartesian orientation of body inertia            (nbody x 9)\nxanchor: Cartesian position of joint anchor               (njnt x 3)\nxaxis: Cartesian joint axis                             (njnt x 3)\ngeom_xpos: Cartesian geom position                          (ngeom x 3)\ngeom_xmat: Cartesian geom orientation                       (ngeom x 9)\nsite_xpos: Cartesian site position                          (nsite x 3)\nsite_xmat: Cartesian site orientation                       (nsite x 9)\ncam_xpos: Cartesian camera position                        (ncam x 3)\ncam_xmat: Cartesian camera orientation                     (ncam x 9)\nlight_xpos: Cartesian light position                         (nlight x 3)\nlight_xdir: Cartesian light direction                        (nlight x 3)\nsubtree_com: center of mass of each subtree                   (nbody x 3)\ncdof: com-based motion axis of each dof                (nv x 6)\ncinert: com-based body inertia and mass                  (nbody x 10)\nten_wrapadr: start address of tendon's path                   (ntendon x 1)\nten_wrapnum: number of wrap points in path                    (ntendon x 1)\nten_J_rownnz: number of non-zeros in Jacobian row              (ntendon x 1)\nten_J_rowadr: row start address in colind array                (ntendon x 1)\nten_J_colind: column indices in sparse Jacobian                (ntendon x nv)\nten_length: tendon lengths                                   (ntendon x 1)\nten_J: tendon Jacobian                                  (ntendon x nv)\nwrap_obj: geom id; -1: site; -2: pulley                    (nwrap*2 x 1)\nwrap_xpos: Cartesian 3D points in all path                  (nwrap*2 x 3)\nactuator_length: actuator lengths                                 (nu x 1)\nactuator_moment: actuator moments                                 (nu x nv)\ncrb: com-based composite inertia and mass             (nbody x 10)\nqM: total inertia (sparse)                           (nM x 1)\nqLD: L'DL factorization of M (sparse)               (nM x 1)\nqLDiagInv: 1/diag(D)                                        (nv x 1)\nqLDiagSqrtInv: 1/sqrt(diag(D))                                  (nv x 1)\nbvh_active: volume has been added to collisions              (nbvh x 1)\nten_velocity: tendon velocities                                (ntendon x 1)\nactuator_velocity: actuator velocities                              (nu x 1)\ncvel: com-based velocity 3D rot; 3D tran\ncdof_dot: time-derivative of cdof                          (nv x 6)\nqfrc_bias: C(qpos,qvel)                                     (nv x 1)\nqfrc_passive: passive force                                    (nv x 1)\nefc_vel: velocity in constraint space: J*qvel             (nefc x 1)\nefc_aref: reference pseudo-acceleration                    (nefc x 1)\nsubtree_linvel: linear velocity of subtree com                   (nbody x 3)\nsubtree_angmom: angular momentum about subtree com               (nbody x 3)\nqH: L'DL factorization of modified M               (nM x 1)\nqHDiagInv: 1/diag(D) of modified M                          (nv x 1)\nD_rownnz: non-zeros in each row                            (nv x 1)\nD_rowadr: address of each row in D_colind                  (nv x 1)\nD_colind: column indices of non-zeros                      (nD x 1)\nB_rownnz: non-zeros in each row                            (nbody x 1)\nB_rowadr: address of each row in B_colind                  (nbody x 1)\nB_colind: column indices of non-zeros                      (nB x 1)\nqDeriv: d (passive + actuator - bias) / d qvel           (nD x 1)\nqLU: sparse LU of (qM - dt*qDeriv)                    (nD x 1)\nactuator_force: actuator force in actuation space                (nu x 1)\nqfrc_actuator: actuator force                                   (nv x 1)\nqfrc_smooth: net unconstrained force                          (nv x 1)\nqacc_smooth: unconstrained acceleration                       (nv x 1)\nqfrc_constraint: constraint force                                 (nv x 1)\nqfrc_inverse: net external force; should equal:                (nv x 1)qfrcapplied + J'*xfrcapplied + qfrc_actuator\ncacc: com-based acceleration                           (nbody x 6)\ncfrc_int: com-based interaction force with parent          (nbody x 6)\ncfrc_ext: com-based external force on body                 (nbody x 6)\ncontact: list of all detected contacts                    (ncon x 1)\nefc_type: constraint type (mjtConstraint)                  (nefc x 1)\nefc_id: id of object of specified type                   (nefc x 1)\nefc_J_rownnz: number of non-zeros in constraint Jacobian row   (nefc x 1)\nefc_J_rowadr: row start address in colind array                (nefc x 1)\nefc_J_rowsuper: number of subsequent rows in supernode           (nefc x 1)\nefc_J_colind: column indices in constraint Jacobian            (nnzJ x 1)\nefc_JT_rownnz: number of non-zeros in constraint Jacobian row T (nv x 1)\nefc_JT_rowadr: row start address in colind array              T (nv x 1)\nefc_JT_rowsuper: number of subsequent rows in supernode         T (nv x 1)\nefc_JT_colind: column indices in constraint Jacobian          T (nnzJ x 1)\nefc_J: constraint Jacobian                              (nnzJ x 1)\nefc_JT: constraint Jacobian transposed                   (nnzJ x 1)\nefc_pos: constraint position (equality, contact)          (nefc x 1)\nefc_margin: inclusion margin (contact)                       (nefc x 1)\nefc_frictionloss: frictionloss (friction)                          (nefc x 1)\nefc_diagApprox: approximation to diagonal of A                   (nefc x 1)\nefc_KBIP: stiffness, damping, impedance, imp'              (nefc x 4)\nefc_D: constraint mass                                  (nefc x 1)\nefc_R: inverse constraint mass                          (nefc x 1)\nefc_b: linear cost term: J*qacc_smooth - aref            (nefc x 1)\nefc_force: constraint force in constraint space              (nefc x 1)\nefc_state: constraint state (mjtConstraintState)             (nefc x 1)\nefc_AR_rownnz: number of non-zeros in AR                         (nefc x 1)\nefc_AR_rowadr: row start address in colind array                 (nefc x 1)\nefc_AR_colind: column indices in sparse AR                       (nefc x nefc)\nefc_AR: Jinv(M)J' + R                                   (nefc x nefc)\n\n\n\n\n\n","category":"type"},{"location":"library/api/#MuJoCo.Wrappers.Model","page":"API","title":"MuJoCo.Wrappers.Model","text":"mjModel\n\nFields\n\nnq: number of generalized coordinates = dim(qpos)\nnv: number of degrees of freedom = dim(qvel)\nnu: number of actuators/controls = dim(ctrl)\nna: number of activation states = dim(act)\nnbody: number of bodies\nnbvh: number of total bounding volumes in all bodies\nnjnt: number of joints\nngeom: number of geoms\nnsite: number of sites\nncam: number of cameras\nnlight: number of lights\nnmesh: number of meshes\nnmeshvert: number of vertices in all meshes\nnmeshnormal: number of normals in all meshes\nnmeshtexcoord: number of texcoords in all meshes\nnmeshface: number of triangular faces in all meshes\nnmeshgraph: number of ints in mesh auxiliary data\nnskin: number of skins\nnskinvert: number of vertices in all skins\nnskintexvert: number of vertiex with texcoords in all skins\nnskinface: number of triangular faces in all skins\nnskinbone: number of bones in all skins\nnskinbonevert: number of vertices in all skin bones\nnhfield: number of heightfields\nnhfielddata: number of data points in all heightfields\nntex: number of textures\nntexdata: number of bytes in texture rgb data\nnmat: number of materials\nnpair: number of predefined geom pairs\nnexclude: number of excluded geom pairs\nneq: number of equality constraints\nntendon: number of tendons\nnwrap: number of wrap objects in all tendon paths\nnsensor: number of sensors\nnnumeric: number of numeric custom fields\nnnumericdata: number of mjtNums in all numeric fields\nntext: number of text custom fields\nntextdata: number of mjtBytes in all text fields\nntuple: number of tuple custom fields\nntupledata: number of objects in all tuple fields\nnkey: number of keyframes\nnmocap: number of mocap bodies\nnplugin: number of plugin instances\nnpluginattr: number of chars in all plugin config attributes\nnuser_body: number of mjtNums in body_user\nnuser_jnt: number of mjtNums in jnt_user\nnuser_geom: number of mjtNums in geom_user\nnuser_site: number of mjtNums in site_user\nnuser_cam: number of mjtNums in cam_user\nnuser_tendon: number of mjtNums in tendon_user\nnuser_actuator: number of mjtNums in actuator_user\nnuser_sensor: number of mjtNums in sensor_user\nnnames: number of chars in all names\nnnames_map: number of slots in the names hash map\nnM: number of non-zeros in sparse inertia matrix\nnD: number of non-zeros in sparse dof-dof matrix\nnB: number of non-zeros in sparse body-dof matrix\nnemax: number of potential equality-constraint rows\nnjmax: number of available rows in constraint Jacobian\nnconmax: number of potential contacts in contact list\nnstack: number of fields in mjData stack\nnuserdata: number of extra fields in mjData\nnsensordata: number of fields in sensor data vector\nnpluginstate: number of fields in the plugin state vector\nnbuffer: number of bytes in buffer\nopt: physics options\nvis: visualization options\nstat: model statistics\nbuffer: main buffer; all pointers point in it    (nbuffer)\nqpos0: qpos values at default pose              (nq x 1)\nqpos_spring: reference pose for springs               (nq x 1)\nbody_parentid: id of body's parent                      (nbody x 1)\nbody_rootid: id of root above body                    (nbody x 1)\nbody_weldid: id of body that this body is welded to   (nbody x 1)\nbody_mocapid: id of mocap data; -1: none               (nbody x 1)\nbody_jntnum: number of joints for this body           (nbody x 1)\nbody_jntadr: start addr of joints; -1: no joints      (nbody x 1)\nbody_dofnum: number of motion degrees of freedom      (nbody x 1)\nbody_dofadr: start addr of dofs; -1: no dofs          (nbody x 1)\nbody_geomnum: number of geoms                          (nbody x 1)\nbody_geomadr: start addr of geoms; -1: no geoms        (nbody x 1)\nbody_simple: body is simple (has diagonal M)          (nbody x 1)\nbody_sameframe: inertial frame is same as body frame     (nbody x 1)\nbody_pos: position offset rel. to parent body      (nbody x 3)\nbody_quat: orientation offset rel. to parent body   (nbody x 4)\nbody_ipos: local position of center of mass         (nbody x 3)\nbody_iquat: local orientation of inertia ellipsoid   (nbody x 4)\nbody_mass: mass                                     (nbody x 1)\nbody_subtreemass: mass of subtree starting at this body    (nbody x 1)\nbody_inertia: diagonal inertia in ipos/iquat frame     (nbody x 3)\nbody_invweight0: mean inv inert in qpos0 (trn, rot)       (nbody x 2)\nbody_gravcomp: antigravity force, units of body weight  (nbody x 1)\nbody_user: user data                                (nbody x nuser_body)\nbody_plugin: plugin instance id; -1: not in use       (nbody x 1)\nbody_bvhadr: address of bvh root                      (nbody x 1)\nbody_bvhnum: number of bounding volumes               (nbody x 1)\nbvh_depth: depth in the bounding volume hierarchy   (nbvh x 1)\nbvh_child: left and right children in tree          (nbvh x 2)\nbvh_geomid: geom id of the node; -1: non-leaf        (nbvh x 1)\nbvh_aabb: bounding box of node (center, size)      (nbvh x 6)\njnt_type: type of joint (mjtJoint)                 (njnt x 1)\njnt_qposadr: start addr in 'qpos' for joint's data    (njnt x 1)\njnt_dofadr: start addr in 'qvel' for joint's data    (njnt x 1)\njnt_bodyid: id of joint's body                       (njnt x 1)\njnt_group: group for visibility                     (njnt x 1)\njnt_limited: does joint have limits                   (njnt x 1)\njnt_actfrclimited: does joint have actuator force limits    (njnt x 1)\njnt_solref: constraint solver reference: limit       (njnt x mjNREF)\njnt_solimp: constraint solver impedance: limit       (njnt x mjNIMP)\njnt_pos: local anchor position                    (njnt x 3)\njnt_axis: local joint axis                         (njnt x 3)\njnt_stiffness: stiffness coefficient                    (njnt x 1)\njnt_range: joint limits                             (njnt x 2)\njnt_actfrcrange: range of total actuator force            (njnt x 2)\njnt_margin: min distance for limit detection         (njnt x 1)\njnt_user: user data                                (njnt x nuser_jnt)\ndof_bodyid: id of dof's body                         (nv x 1)\ndof_jntid: id of dof's joint                        (nv x 1)\ndof_parentid: id of dof's parent; -1: none             (nv x 1)\ndof_Madr: dof address in M-diagonal                (nv x 1)\ndof_simplenum: number of consecutive simple dofs        (nv x 1)\ndof_solref: constraint solver reference:frictionloss (nv x mjNREF)\ndof_solimp: constraint solver impedance:frictionloss (nv x mjNIMP)\ndof_frictionloss: dof friction loss                        (nv x 1)\ndof_armature: dof armature inertia/mass                (nv x 1)\ndof_damping: damping coefficient                      (nv x 1)\ndof_invweight0: diag. inverse inertia in qpos0           (nv x 1)\ndof_M0: diag. inertia in qpos0                   (nv x 1)\ngeom_type: geometric type (mjtGeom)                 (ngeom x 1)\ngeom_contype: geom contact type                        (ngeom x 1)\ngeom_conaffinity: geom contact affinity                    (ngeom x 1)\ngeom_condim: contact dimensionality (1, 3, 4, 6)      (ngeom x 1)\ngeom_bodyid: id of geom's body                        (ngeom x 1)\ngeom_dataid: id of geom's mesh/hfield; -1: none       (ngeom x 1)\ngeom_matid: material id for rendering; -1: none      (ngeom x 1)\ngeom_group: group for visibility                     (ngeom x 1)\ngeom_priority: geom contact priority                    (ngeom x 1)\ngeom_sameframe: same as body frame (1) or iframe (2)     (ngeom x 1)\ngeom_solmix: mixing coef for solref/imp in geom pair  (ngeom x 1)\ngeom_solref: constraint solver reference: contact     (ngeom x mjNREF)\ngeom_solimp: constraint solver impedance: contact     (ngeom x mjNIMP)\ngeom_size: geom-specific size parameters            (ngeom x 3)\ngeom_aabb: bounding box, (center, size)             (ngeom x 6)\ngeom_rbound: radius of bounding sphere                (ngeom x 1)\ngeom_pos: local position offset rel. to body       (ngeom x 3)\ngeom_quat: local orientation offset rel. to body    (ngeom x 4)\ngeom_friction: friction for (slide, spin, roll)         (ngeom x 3)\ngeom_margin: detect contact if dist<margin(ngeom x 1)\ngeom_gap: include in solver if dist<margin-gap     (ngeom x 1)\ngeom_fluid: fluid interaction parameters             (ngeom x mjNFLUID)\ngeom_user: user data                                (ngeom x nuser_geom)\ngeom_rgba: rgba when material is omitted            (ngeom x 4)\nsite_type: geom type for rendering (mjtGeom)        (nsite x 1)\nsite_bodyid: id of site's body                        (nsite x 1)\nsite_matid: material id for rendering; -1: none      (nsite x 1)\nsite_group: group for visibility                     (nsite x 1)\nsite_sameframe: same as body frame (1) or iframe (2)     (nsite x 1)\nsite_size: geom size for rendering                  (nsite x 3)\nsite_pos: local position offset rel. to body       (nsite x 3)\nsite_quat: local orientation offset rel. to body    (nsite x 4)\nsite_user: user data                                (nsite x nuser_site)\nsite_rgba: rgba when material is omitted            (nsite x 4)\ncam_mode: camera tracking mode (mjtCamLight)       (ncam x 1)\ncam_bodyid: id of camera's body                      (ncam x 1)\ncam_targetbodyid: id of targeted body; -1: none            (ncam x 1)\ncam_pos: position rel. to body frame              (ncam x 3)\ncam_quat: orientation rel. to body frame           (ncam x 4)\ncam_poscom0: global position rel. to sub-com in qpos0 (ncam x 3)\ncam_pos0: global position rel. to body in qpos0    (ncam x 3)\ncam_mat0: global orientation in qpos0              (ncam x 9)\ncam_fovy: y-field of view (deg)                    (ncam x 1)\ncam_ipd: inter-pupilary distance                  (ncam x 1)\ncam_user: user data                                (ncam x nuser_cam)\nlight_mode: light tracking mode (mjtCamLight)        (nlight x 1)\nlight_bodyid: id of light's body                       (nlight x 1)\nlight_targetbodyid: id of targeted body; -1: none            (nlight x 1)\nlight_directional: directional light                        (nlight x 1)\nlight_castshadow: does light cast shadows                  (nlight x 1)\nlight_active: is light on                              (nlight x 1)\nlight_pos: position rel. to body frame              (nlight x 3)\nlight_dir: direction rel. to body frame             (nlight x 3)\nlight_poscom0: global position rel. to sub-com in qpos0 (nlight x 3)\nlight_pos0: global position rel. to body in qpos0    (nlight x 3)\nlight_dir0: global direction in qpos0                (nlight x 3)\nlight_attenuation: OpenGL attenuation (quadratic model)     (nlight x 3)\nlight_cutoff: OpenGL cutoff                            (nlight x 1)\nlight_exponent: OpenGL exponent                          (nlight x 1)\nlight_ambient: ambient rgb (alpha=1)                    (nlight x 3)\nlight_diffuse: diffuse rgb (alpha=1)                    (nlight x 3)\nlight_specular: specular rgb (alpha=1)                   (nlight x 3)\nmesh_vertadr: first vertex address                     (nmesh x 1)\nmesh_vertnum: number of vertices                       (nmesh x 1)\nmesh_faceadr: first face address                       (nmesh x 1)\nmesh_facenum: number of faces                          (nmesh x 1)\nmesh_bvhadr: address of bvh root                      (nmesh x 1)\nmesh_bvhnum: number of bvh                            (nmesh x 1)\nmesh_normaladr: first normal address                     (nmesh x 1)\nmesh_normalnum: number of normals                        (nmesh x 1)\nmesh_texcoordadr: texcoord data address; -1: no texcoord   (nmesh x 1)\nmesh_texcoordnum: number of texcoord                       (nmesh x 1)\nmesh_graphadr: graph data address; -1: no graph         (nmesh x 1)\nmesh_vert: vertex positions for all meshes          (nmeshvert x 3)\nmesh_normal: normals for all meshes                   (nmeshnormal x 3)\nmesh_texcoord: vertex texcoords for all meshes          (nmeshtexcoord x 2)\nmesh_face: vertex face data                         (nmeshface x 3)\nmesh_facenormal: normal face data                         (nmeshface x 3)\nmesh_facetexcoord: texture face data                        (nmeshface x 3)\nmesh_graph: convex graph data                        (nmeshgraph x 1)\nskin_matid: skin material id; -1: none               (nskin x 1)\nskin_group: group for visibility                     (nskin x 1)\nskin_rgba: skin rgba                                (nskin x 4)\nskin_inflate: inflate skin in normal direction         (nskin x 1)\nskin_vertadr: first vertex address                     (nskin x 1)\nskin_vertnum: number of vertices                       (nskin x 1)\nskin_texcoordadr: texcoord data address; -1: no texcoord   (nskin x 1)\nskin_faceadr: first face address                       (nskin x 1)\nskin_facenum: number of faces                          (nskin x 1)\nskin_boneadr: first bone in skin                       (nskin x 1)\nskin_bonenum: number of bones in skin                  (nskin x 1)\nskin_vert: vertex positions for all skin meshes     (nskinvert x 3)\nskin_texcoord: vertex texcoords for all skin meshes     (nskintexvert x 2)\nskin_face: triangle faces for all skin meshes       (nskinface x 3)\nskin_bonevertadr: first vertex in each bone                (nskinbone x 1)\nskin_bonevertnum: number of vertices in each bone          (nskinbone x 1)\nskin_bonebindpos: bind pos of each bone                    (nskinbone x 3)\nskin_bonebindquat: bind quat of each bone                   (nskinbone x 4)\nskin_bonebodyid: body id of each bone                     (nskinbone x 1)\nskin_bonevertid: mesh ids of vertices in each bone        (nskinbonevert x 1)\nskin_bonevertweight: weights of vertices in each bone         (nskinbonevert x 1)\nhfield_size: (x, y, ztop, zbottom)                  (nhfield x 4)\nhfield_nrow: number of rows in grid                   (nhfield x 1)\nhfield_ncol: number of columns in grid                (nhfield x 1)\nhfield_adr: address in hfield_data                   (nhfield x 1)\nhfield_data: elevation data                           (nhfielddata x 1)\ntex_type: texture type (mjtTexture)                (ntex x 1)\ntex_height: number of rows in texture image          (ntex x 1)\ntex_width: number of columns in texture image       (ntex x 1)\ntex_adr: address in rgb                           (ntex x 1)\ntex_rgb: rgb (alpha = 1)                          (ntexdata x 1)\nmat_texid: texture id; -1: none                     (nmat x 1)\nmat_texuniform: make texture cube uniform                (nmat x 1)\nmat_texrepeat: texture repetition for 2d mapping        (nmat x 2)\nmat_emission: emission (x rgb)                         (nmat x 1)\nmat_specular: specular (x white)                       (nmat x 1)\nmat_shininess: shininess coef                           (nmat x 1)\nmat_reflectance: reflectance (0: disable)                 (nmat x 1)\nmat_rgba: rgba                                     (nmat x 4)\npair_dim: contact dimensionality                   (npair x 1)\npair_geom1: id of geom1                              (npair x 1)\npair_geom2: id of geom2                              (npair x 1)\npair_signature: (body1+1)<<16 + body2+1                (npair x 1)\npair_solref: solver reference: contact normal         (npair x mjNREF)\npair_solreffriction: solver reference: contact friction       (npair x mjNREF)\npair_solimp: solver impedance: contact                (npair x mjNIMP)\npair_margin: detect contact if dist<margin(npair x 1)\npair_gap: include in solver if dist<margin-gap     (npair x 1)\npair_friction: tangent1, 2, spin, roll1, 2              (npair x 5)\nexclude_signature: (body1+1)<<16 + body2+1                (nexclude x 1)\neq_type: constraint type (mjtEq)                  (neq x 1)\neq_obj1id: id of object 1                           (neq x 1)\neq_obj2id: id of object 2                           (neq x 1)\neq_active: enable/disable constraint                (neq x 1)\neq_solref: constraint solver reference              (neq x mjNREF)\neq_solimp: constraint solver impedance              (neq x mjNIMP)\neq_data: numeric data for constraint              (neq x mjNEQDATA)\ntendon_adr: address of first object in tendon's path (ntendon x 1)\ntendon_num: number of objects in tendon's path       (ntendon x 1)\ntendon_matid: material id for rendering                (ntendon x 1)\ntendon_group: group for visibility                     (ntendon x 1)\ntendon_limited: does tendon have length limits           (ntendon x 1)\ntendon_width: width for rendering                      (ntendon x 1)\ntendon_solref_lim: constraint solver reference: limit       (ntendon x mjNREF)\ntendon_solimp_lim: constraint solver impedance: limit       (ntendon x mjNIMP)\ntendon_solref_fri: constraint solver reference: friction    (ntendon x mjNREF)\ntendon_solimp_fri: constraint solver impedance: friction    (ntendon x mjNIMP)\ntendon_range: tendon length limits                     (ntendon x 2)\ntendon_margin: min distance for limit detection         (ntendon x 1)\ntendon_stiffness: stiffness coefficient                    (ntendon x 1)\ntendon_damping: damping coefficient                      (ntendon x 1)\ntendon_frictionloss: loss due to friction                     (ntendon x 1)\ntendon_lengthspring: spring resting length range              (ntendon x 2)\ntendon_length0: tendon length in qpos0                   (ntendon x 1)\ntendon_invweight0: inv. weight in qpos0                     (ntendon x 1)\ntendon_user: user data                                (ntendon x nuser_tendon)\ntendon_rgba: rgba when material is omitted            (ntendon x 4)\nwrap_type: wrap object type (mjtWrap)               (nwrap x 1)\nwrap_objid: object id: geom, site, joint             (nwrap x 1)\nwrap_prm: divisor, joint coef, or site id          (nwrap x 1)\nactuator_trntype: transmission type (mjtTrn)               (nu x 1)\nactuator_dyntype: dynamics type (mjtDyn)                   (nu x 1)\nactuator_gaintype: gain type (mjtGain)                      (nu x 1)\nactuator_biastype: bias type (mjtBias)                      (nu x 1)\nactuator_trnid: transmission id: joint, tendon, site     (nu x 2)\nactuator_actadr: first activation address; -1: stateless  (nu x 1)\nactuator_actnum: number of activation variables           (nu x 1)\nactuator_group: group for visibility                     (nu x 1)\nactuator_ctrllimited: is control limited                       (nu x 1)\nactuator_forcelimited: is force limited                         (nu x 1)\nactuator_actlimited: is activation limited                    (nu x 1)\nactuator_dynprm: dynamics parameters                      (nu x mjNDYN)\nactuator_gainprm: gain parameters                          (nu x mjNGAIN)\nactuator_biasprm: bias parameters                          (nu x mjNBIAS)\nactuator_ctrlrange: range of controls                        (nu x 2)\nactuator_forcerange: range of forces                          (nu x 2)\nactuator_actrange: range of activations                     (nu x 2)\nactuator_gear: scale length and transmitted force       (nu x 6)\nactuator_cranklength: crank length for slider-crank            (nu x 1)\nactuator_acc0: acceleration from unit force in qpos0    (nu x 1)\nactuator_length0: actuator length in qpos0                 (nu x 1)\nactuator_lengthrange: feasible actuator length range           (nu x 2)\nactuator_user: user data                                (nu x nuser_actuator)\nactuator_plugin: plugin instance id; -1: not a plugin     (nu x 1)\nsensor_type: sensor type (mjtSensor)                  (nsensor x 1)\nsensor_datatype: numeric data type (mjtDataType)          (nsensor x 1)\nsensor_needstage: required compute stage (mjtStage)        (nsensor x 1)\nsensor_objtype: type of sensorized object (mjtObj)       (nsensor x 1)\nsensor_objid: id of sensorized object                  (nsensor x 1)\nsensor_reftype: type of reference frame (mjtObj)         (nsensor x 1)\nsensor_refid: id of reference frame; -1: global frame  (nsensor x 1)\nsensor_dim: number of scalar outputs                 (nsensor x 1)\nsensor_adr: address in sensor array                  (nsensor x 1)\nsensor_cutoff: cutoff for real and positive; 0: ignore  (nsensor x 1)\nsensor_noise: noise standard deviation                 (nsensor x 1)\nsensor_user: user data                                (nsensor x nuser_sensor)\nsensor_plugin: plugin instance id; -1: not a plugin     (nsensor x 1)\nplugin: globally registered plugin slot number   (nplugin x 1)\nplugin_stateadr: address in the plugin state array        (nplugin x 1)\nplugin_statenum: number of states in the plugin instance  (nplugin x 1)\nplugin_attr: config attributes of plugin instances    (npluginattr x 1)\nplugin_attradr: address to each instance's config attrib (nplugin x 1)\nnumeric_adr: address of field in numeric_data         (nnumeric x 1)\nnumeric_size: size of numeric field                    (nnumeric x 1)\nnumeric_data: array of all numeric fields              (nnumericdata x 1)\ntext_adr: address of text in text_data             (ntext x 1)\ntext_size: size of text field (strlen+1)            (ntext x 1)\ntext_data: array of all text fields (0-terminated)  (ntextdata x 1)\ntuple_adr: address of text in text_data             (ntuple x 1)\ntuple_size: number of objects in tuple               (ntuple x 1)\ntuple_objtype: array of object types in all tuples      (ntupledata x 1)\ntuple_objid: array of object ids in all tuples        (ntupledata x 1)\ntuple_objprm: array of object params in all tuples     (ntupledata x 1)\nkey_time: key time                                 (nkey x 1)\nkey_qpos: key position                             (nkey x nq)\nkey_qvel: key velocity                             (nkey x nv)\nkey_act: key activation                           (nkey x na)\nkey_mpos: key mocap position                       (nkey x 3*nmocap)\nkey_mquat: key mocap quaternion                     (nkey x 4*nmocap)\nkey_ctrl: key control                              (nkey x nu)\nname_bodyadr: body name pointers                       (nbody x 1)\nname_jntadr: joint name pointers                      (njnt x 1)\nname_geomadr: geom name pointers                       (ngeom x 1)\nname_siteadr: site name pointers                       (nsite x 1)\nname_camadr: camera name pointers                     (ncam x 1)\nname_lightadr: light name pointers                      (nlight x 1)\nname_meshadr: mesh name pointers                       (nmesh x 1)\nname_skinadr: skin name pointers                       (nskin x 1)\nname_hfieldadr: hfield name pointers                     (nhfield x 1)\nname_texadr: texture name pointers                    (ntex x 1)\nname_matadr: material name pointers                   (nmat x 1)\nname_pairadr: geom pair name pointers                  (npair x 1)\nname_excludeadr: exclude name pointers                    (nexclude x 1)\nname_eqadr: equality constraint name pointers        (neq x 1)\nname_tendonadr: tendon name pointers                     (ntendon x 1)\nname_actuatoradr: actuator name pointers                   (nu x 1)\nname_sensoradr: sensor name pointers                     (nsensor x 1)\nname_numericadr: numeric name pointers                    (nnumeric x 1)\nname_textadr: text name pointers                       (ntext x 1)\nname_tupleadr: tuple name pointers                      (ntuple x 1)\nname_keyadr: keyframe name pointers                   (nkey x 1)\nname_pluginadr: plugin instance name pointers            (nplugin x 1)\nnames: names of all objects, 0-terminated       (nnames x 1)\nnames_map: internal hash map of names               (nnames_map x 1)\n\n\n\n\n\n","category":"type"},{"location":"library/api/#MuJoCo.Wrappers.Options","page":"API","title":"MuJoCo.Wrappers.Options","text":"mjOption\n\nFields\n\ntimestep: timestep\napirate: update rate for remote API (Hz)\nimpratio: ratio of friction-to-normal contact impedance\ntolerance: main solver tolerance\nnoslip_tolerance: noslip solver tolerance\nmpr_tolerance: MPR solver tolerance\ngravity: gravitational acceleration\nwind: wind (for lift, drag and viscosity)\nmagnetic: global magnetic flux\ndensity: density of medium\nviscosity: viscosity of medium\no_margin: margin\no_solref: solref\no_solimp: solimp\nintegrator: integration mode (mjtIntegrator)\ncollision: collision mode (mjtCollision)\ncone: type of friction cone (mjtCone)\njacobian: type of Jacobian (mjtJacobian)\nsolver: solver algorithm (mjtSolver)\niterations: maximum number of main solver iterations\nnoslip_iterations: maximum number of noslip solver iterations\nmpr_iterations: maximum number of MPR solver iterations\ndisableflags: bit flags for disabling standard features\nenableflags: bit flags for enabling optional features\n\n\n\n\n\n","category":"type"},{"location":"library/api/#MuJoCo.Wrappers.Statistics","page":"API","title":"MuJoCo.Wrappers.Statistics","text":"mjStatistic\n\nFields\n\nmeaninertia: mean diagonal inertia\nmeanmass: mean body mass\nmeansize: mean body size\nextent: spatial extent\ncenter: center of model\n\n\n\n\n\n","category":"type"},{"location":"library/api/#MuJoCo.example_model_files-Tuple{}","page":"API","title":"MuJoCo.example_model_files","text":"Returns the list of absolute paths to available example model files provided by MuJoCo.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.example_model_files_directory-Tuple{}","page":"API","title":"MuJoCo.example_model_files_directory","text":"Returns the absolute path of the root directory containing all the example model files.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.forward!-Tuple{Union{MuJoCo.Wrappers.NamedAccess.NamedModel, Model}, Union{MuJoCo.Wrappers.NamedAccess.NamedData, Data}}","page":"API","title":"MuJoCo.forward!","text":"forward!(model::MODEL_TYPES, data::DATA_TYPES)\n\nSame as step! but without integrating in time.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.get_physics_state-Tuple{Model, Data}","page":"API","title":"MuJoCo.get_physics_state","text":"get_physics_state(m::Model, d::Data)\n\nExtract the state vector of a MuJoCo model.\n\nThe state vector is [joint positions, joint velocities, actuator states] with dimension (nq, nv, na). \n\nSee also mj_getState and set_physics_state!.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.humanoid_model_file-Tuple{}","page":"API","title":"MuJoCo.humanoid_model_file","text":"Returns the absolute path to the humanoid model provided by MuJoCo.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.init_data-Tuple{Model}","page":"API","title":"MuJoCo.init_data","text":"init_data(model::Model)\n\nCreates an instance of the data required for the step! simulation.\n\nReturns a Data object, wrapping the underlying mjData object.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.init_visualiser-Tuple{}","page":"API","title":"MuJoCo.init_visualiser","text":"init_visualiser()\n\nLoads the packages necessary for the running the visualiser.\n\nAdd the following packages to your project to be able to use the visualisation features, or run \"install_visualiser()\".\n\nPackages:\n\nBangBang\nFFMPEG\nGLFW\nObservables\nPrettyTables\nPrintf\nStaticArrays\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.install_visualiser-Tuple{}","page":"API","title":"MuJoCo.install_visualiser","text":"install_visualiser()\n\nInstalls the necessary packages for the running the visualiser into the current running environment.\n\nPackages:\n\nBangBang\nFFMPEG\nGLFW\nObservables\nPrettyTables\nPrintf\nStaticArrays\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.load_model-Tuple{AbstractString}","page":"API","title":"MuJoCo.load_model","text":"load_model(path)\n\nDetermines the type of file by the extension and loads the model into memory.\n\nTo use this model in a simulator, you will also need the corresponding data, obtained using init_data.\n\nExpected files types: 'xml', 'mjcf', or 'mjb' (or uppercase variants).\n\nExamples\n\nmodel = load_model(MuJoCo.humanoid_model_file())\ndata = init_data(model)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_addM-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Int32}, AbstractVecOrMat{Int32}, AbstractVecOrMat{Int32}}","page":"API","title":"MuJoCo.mj_addM","text":"mj_addM(m, d, dst, rownnz, rowadr, colind)\n\nAdd inertia matrix to destination matrix. Destination can be sparse uncompressed, or dense when all int* are NULL\n\nArguments\n\nm::Model -> Constant.\nd::Data\ndst::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nrownnz::Vector{Int32} -> A vector of variable size. Check additional info for sizes.\nrowadr::Vector{Int32} -> A vector of variable size. Check additional info for sizes.\ncolind::Vector{Int32} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\ndst should be a vector, not a matrix.\nrownnz should be a vector, not a matrix.\nrowadr should be a vector, not a matrix.\ncolind should be a vector, not a matrix.\ndst should be of size nM\nrownnz should be of size nv\nrowadr should be of size nv\ncolind should be of size nM\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_applyFT-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Integer, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_applyFT","text":"mj_applyFT(m, d, force, torque, point, body, qfrc_target)\n\nApply Cartesian force and torque (outside xfrc_applied mechanism).\n\nArguments\n\nm::Model -> Constant.\nd::Data\nforce::Vector{Float64} -> A vector of size 3. Constant.\ntorque::Vector{Float64} -> A vector of size 3. Constant.\npoint::Vector{Float64} -> A vector of size 3. Constant.\nbody::Int32\nqfrc_target::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nforce should be a vector of size 3\nforce should be a vector of size 3.\ntorque should be a vector of size 3\ntorque should be a vector of size 3.\npoint should be a vector of size 3\npoint should be a vector of size 3.\nqfrc_target should be a vector, not a matrix.\nqfrc_target should be of size nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_array-Tuple{DataType, Vararg{Any}}","page":"API","title":"MuJoCo.mj_array","text":"mj_array([element_type=mjtNum], dims...)\n\nAllocates an array compatible with the underlying MuJoCo C API.\n\nThe C API treats arrays as row-major, while by default arrays in Julia are column-major. This function will create an array which is accessed in a row-major way, but can be treated by a normal  array in your Julia code.\n\nArguments\n\nelement_type: Defaults to mjtNum (typically Float64).\ndims: The dimensionality of output array. Can either be a tuple of integers or a series of integers.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_constraintUpdate-Tuple{Any, Any, AbstractVecOrMat{Float64}, Union{Nothing, AbstractVecOrMat{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_constraintUpdate","text":"mj_constraintUpdate(m, d, jar, cost, flg_coneHessian)\n\nCompute efcstate, efcforce, qfrc_constraint, and (optionally) cone Hessians. If cost is not NULL, set cost = s(jar) where jar = Jacqacc-aref.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njar::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\ncost::Vector{Float64} -> An optional vector of size 1.\nflg_coneHessian::Int32\n\nAdditional Info\n\njar should be a vector, not a matrix.\ncost should be a vector of size 1\ncost should be a vector of size 1.\nsize of jar should equal nefc\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_differentiatePos-Tuple{Any, AbstractVecOrMat{Float64}, Real, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_differentiatePos","text":"mj_differentiatePos(m, qvel, dt, qpos1, qpos2)\n\nCompute velocity by finite-differencing two positions.\n\nArguments\n\nm::Model -> Constant.\nqvel::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\ndt::Float64\nqpos1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nqpos2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nqvel should be a vector, not a matrix.\nqpos1 should be a vector, not a matrix.\nqpos2 should be a vector, not a matrix.\nqvel should be of size nv\nqpos1 should be of size nq\nqpos2 should be of size nq\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_fullM-Tuple{Any, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_fullM","text":"mj_fullM(m, dst, M)\n\nConvert sparse inertia matrix M into full (i.e. dense) matrix.\n\nArguments\n\nm::Model -> Constant.\ndst::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nM::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nM should be a vector, not a matrix.\nM should be of size nM\ndst should be of shape (nv, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_getState-Tuple{Any, Any, AbstractVecOrMat{Float64}, Integer}","page":"API","title":"MuJoCo.mj_getState","text":"mj_getState(m, d, state, spec)\n\nGet state.\n\nArguments\n\nm::Model -> Constant.\nd::Data -> Constant.\nstate::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nspec::Int32\n\nAdditional Info\n\nstate should be a vector, not a matrix.\nstate size should equal mj_stateSize(m, spec)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_integratePos-Tuple{Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Real}","page":"API","title":"MuJoCo.mj_integratePos","text":"mj_integratePos(m, qpos, qvel, dt)\n\nIntegrate position with given velocity.\n\nArguments\n\nm::Model -> Constant.\nqpos::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nqvel::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\ndt::Float64\n\nAdditional Info\n\nqpos should be a vector, not a matrix.\nqvel should be a vector, not a matrix.\nqpos should be of size nq\nqvel should be of size nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jac-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, AbstractVecOrMat{Float64}, Integer}","page":"API","title":"MuJoCo.mj_jac","text":"mj_jac(m, d, jacp, jacr, point, body)\n\nCompute 3/6-by-nv end-effector Jacobian of global point attached to given body.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\npoint::Vector{Float64} -> A vector of size 3. Constant.\nbody::Int32\n\nAdditional Info\n\npoint should be a vector of size 3\npoint should be a vector of size 3.\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacBody-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_jacBody","text":"mj_jacBody(m, d, jacp, jacr, body)\n\nCompute body frame end-effector Jacobian.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nbody::Int32\n\nAdditional Info\n\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacBodyCom-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_jacBodyCom","text":"mj_jacBodyCom(m, d, jacp, jacr, body)\n\nCompute body center-of-mass end-effector Jacobian.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nbody::Int32\n\nAdditional Info\n\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacGeom-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_jacGeom","text":"mj_jacGeom(m, d, jacp, jacr, geom)\n\nCompute geom end-effector Jacobian.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\ngeom::Int32\n\nAdditional Info\n\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacPointAxis-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Integer}","page":"API","title":"MuJoCo.mj_jacPointAxis","text":"mj_jacPointAxis(m, d, jacp, jacr, point, axis, body)\n\nCompute translation end-effector Jacobian of point, and rotation Jacobian of axis.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\npoint::Vector{Float64} -> A vector of size 3. Constant.\naxis::Vector{Float64} -> A vector of size 3. Constant.\nbody::Int32\n\nAdditional Info\n\npoint should be a vector of size 3\npoint should be a vector of size 3.\naxis should be a vector of size 3\naxis should be a vector of size 3.\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacSite-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Union{Nothing, AbstractMatrix{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_jacSite","text":"mj_jacSite(m, d, jacp, jacr, site)\n\nCompute site end-effector Jacobian.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\njacr::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nsite::Int32\n\nAdditional Info\n\njacp should be of shape (3, nv)\njacr should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_jacSubtreeCom-Tuple{Any, Any, Union{Nothing, AbstractMatrix{Float64}}, Integer}","page":"API","title":"MuJoCo.mj_jacSubtreeCom","text":"mj_jacSubtreeCom(m, d, jacp, body)\n\nCompute subtree center-of-mass end-effector Jacobian.\n\nArguments\n\nm::Model -> Constant.\nd::Data\njacp::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nbody::Int32\n\nAdditional Info\n\njacp should be of shape (3, nv)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_mulJacTVec-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_mulJacTVec","text":"mj_mulJacTVec(m, d, res, vec)\n\nMultiply dense or sparse constraint Jacobian transpose by vector.\n\nArguments\n\nm::Model -> Constant.\nd::Data\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres should be of length nv\nvec should be of length nefc\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_mulJacVec-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_mulJacVec","text":"mj_mulJacVec(m, d, res, vec)\n\nMultiply dense or sparse constraint Jacobian by vector.\n\nArguments\n\nm::Model -> Constant.\nd::Data\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres should be of length nefc\nvec should be of length nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_mulM-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_mulM","text":"mj_mulM(m, d, res, vec)\n\nMultiply vector by inertia matrix.\n\nArguments\n\nm::Model -> Constant.\nd::Data -> Constant.\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres should be of size nv\nvec should be of size nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_mulM2-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_mulM2","text":"mj_mulM2(m, d, res, vec)\n\nMultiply vector by (inertia matrix)^(1/2).\n\nArguments\n\nm::Model -> Constant.\nd::Data -> Constant.\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres should be of size nv\nvec should be of size nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_normalizeQuat-Tuple{Any, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_normalizeQuat","text":"mj_normalizeQuat(m, qpos)\n\nNormalize all quaternions in qpos-type vector.\n\nArguments\n\nm::Model -> Constant.\nqpos::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nqpos should be a vector, not a matrix.\nqpos should be of size nq\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_ray-Tuple{Any, Any, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Union{Nothing, AbstractVecOrMat{UInt8}}, Union{Bool, UInt8}, Integer, AbstractVecOrMat{Int32}}","page":"API","title":"MuJoCo.mj_ray","text":"mj_ray(m, d, pnt, vec, geomgroup, flg_static, bodyexclude, geomid)\n\nIntersect ray (pnt+x*vec, x>=0) with visible geoms, except geoms in bodyexclude. Return distance (x) to nearest surface, or -1 if no intersection and output geomid. geomgroup, flg_static are as in mjvOption; geomgroup==NULL skips group exclusion.\n\nArguments\n\nm::Model -> Constant.\nd::Data -> Constant.\npnt::Vector{Float64} -> A vector of size 3. Constant.\nvec::Vector{Float64} -> A vector of size 3. Constant.\ngeomgroup::Vector{UInt8} -> An optional vector of size 6. Constant.\nflg_static::UInt8\nbodyexclude::Int32\ngeomid::Vector{Int32} -> A vector of size 1.\n\nAdditional Info\n\npnt should be a vector of size 3\npnt should be a vector of size 3.\nvec should be a vector of size 3\nvec should be a vector of size 3.\ngeomgroup should be a vector of size 6\ngeomgroup should be a vector of size 6.\ngeomid should be a vector of size 1\ngeomid should be a vector of size 1.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_rne-Tuple{Any, Any, Integer, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mj_rne","text":"mj_rne(m, d, flg_acc, result)\n\nRNE: compute M(qpos)*qacc + C(qpos,qvel); flg_acc=0 removes inertial term.\n\nArguments\n\nm::Model -> Constant.\nd::Data\nflg_acc::Int32\nresult::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nresult should be a vector, not a matrix.\nresult should have length nv\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_setState-Tuple{Any, Any, AbstractVecOrMat{Float64}, Integer}","page":"API","title":"MuJoCo.mj_setState","text":"mj_setState(m, d, state, spec)\n\nSet state.\n\nArguments\n\nm::Model -> Constant.\nd::Data\nstate::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nspec::Int32\n\nAdditional Info\n\nstate should be a vector, not a matrix.\nstate size should equal mj_stateSize(m, spec)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_solveM-Tuple{Any, Any, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mj_solveM","text":"mj_solveM(m, d, x, y)\n\nSolve linear system M * x = y using factorization:  x = inv(L'DL)*y\n\nArguments\n\nm::Model -> Constant.\nd::Data\nx::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\ny::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_solveM2-Tuple{Any, Any, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mj_solveM2","text":"mj_solveM2(m, d, x, y)\n\nHalf of linear solve:  x = sqrt(inv(D))inv(L')y\n\nArguments\n\nm::Model -> Constant.\nd::Data\nx::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\ny::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mj_zeros-Tuple{DataType, Vararg{Any}}","page":"API","title":"MuJoCo.mj_zeros","text":"mj_zeros([element_type=mjtNum], dims...)\n\nAllocates an array full of zeros, compatible with the underlying MuJoCo C API.\n\nThe C API treats arrays as row-major, while by default arrays in Julia are column-major. This function will create an array which is accessed in a row-major way, but can be treated by a normal  array in your Julia code.\n\nArguments\n\nelement_type: The element type of the array. Defaults to mjtNum (typically Float64).\ndims: The dimensionality of output array. Can either be a tuple of integers or a series of integers.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mjd_inverseFD-Tuple{Any, Any, Real, Union{Bool, UInt8}, Vararg{Union{Nothing, AbstractMatrix{Float64}}, 7}}","page":"API","title":"MuJoCo.mjd_inverseFD","text":"mjd_inverseFD(m, d, eps, flg_actuation, DfDq, DfDv, DfDa, DsDq, DsDv, DsDa, DmDq)\n\nFinite differenced Jacobians of (force, sensors) = mjinverse(state, acceleration)   All outputs are optional. Output dimensions (transposed w.r.t Control Theory convention):     DfDq: (nv x nv)     DfDv: (nv x nv)     DfDa: (nv x nv)     DsDq: (nv x nsensordata)     DsDv: (nv x nsensordata)     DsDa: (nv x nsensordata)     DmDq: (nv x nM)   single-letter shortcuts:     inputs: q=qpos, v=qvel, a=qacc     outputs: f=qfrcinverse, s=sensordata, m=qM   notes:     optionally computes mass matrix Jacobian DmDq     flgactuation specifies whether to subtract qfrcactuator from qfrc_inverse\n\nArguments\n\nm::Model -> Constant.\nd::Data\neps::Float64\nflg_actuation::UInt8\nDfDq::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDfDv::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDfDa::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDsDq::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDsDv::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDsDa::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nDmDq::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\n\nAdditional Info\n\nDfDq should be of shape (nv, nv)\nDfDv should be of shape (nv, nv)\nDfDa should be of shape (nv, nv)\nDsDq should be of shape (nv, nsensordata)\nDsDv should be of shape (nv, nsensordata)\nDsDa should be of shape (nv, nsensordata)\nDmDq should be of shape (nv, nM)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mjd_transitionFD-Tuple{Any, Any, Real, Union{Bool, UInt8}, Vararg{Union{Nothing, AbstractMatrix{Float64}}, 4}}","page":"API","title":"MuJoCo.mjd_transitionFD","text":"mjd_transitionFD(m, d, eps, flg_centered, A, B, C, D)\n\nFinite differenced transition matrices (control theory notation)   d(x_next) = Adx + Bdu   d(sensor) = Cdx + Ddu   required output matrix dimensions:      A: (2nv+na x 2nv+na)      B: (2nv+na x nu)      D: (nsensordata x 2nv+na)      C: (nsensordata x nu)\n\nArguments\n\nm::Model -> Constant.\nd::Data\neps::Float64\nflg_centered::UInt8\nA::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nB::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nC::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nD::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\n\nAdditional Info\n\nA should be of shape (2nv+na, 2nv+na)\nB should be of shape (2*nv+na, nu)\nC should be of shape (nsensordata, 2*nv+na)\nD should be of shape (nsensordata, nu)\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_L1-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_L1","text":"mju_L1(vec)\n\nReturn L1 norm: sum(abs(vec)).\n\nArguments\n\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_add-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_add","text":"mju_add(res, vec1, vec2)\n\nSet res = vec1 + vec2.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nvec2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec1 should be a vector, not a matrix.\nvec2 should be a vector, not a matrix.\nres and vec1 should have the same size\nres and vec2 should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_addScl-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Real}","page":"API","title":"MuJoCo.mju_addScl","text":"mju_addScl(res, vec1, vec2, scl)\n\nSet res = vec1 + vec2*scl.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nvec2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nscl::Float64\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec1 should be a vector, not a matrix.\nvec2 should be a vector, not a matrix.\nres and vec1 should have the same size\nres and vec2 should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_addTo-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_addTo","text":"mju_addTo(res, vec)\n\nSet res = res + vec.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_addToScl-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Real}","page":"API","title":"MuJoCo.mju_addToScl","text":"mju_addToScl(res, vec, scl)\n\nSet res = res + vec*scl.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nscl::Float64\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_band2Dense-Tuple{AbstractMatrix{Float64}, AbstractVecOrMat{Float64}, Integer, Integer, Integer, Union{Bool, UInt8}}","page":"API","title":"MuJoCo.mju_band2Dense","text":"mju_band2Dense(res, mat, ntotal, nband, ndense, flg_sym)\n\nConvert banded matrix to dense matrix, fill upper triangle if flg_sym>0.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nntotal::Int32\nnband::Int32\nndense::Int32\nflg_sym::UInt8\n\nAdditional Info\n\nmat should be a vector, not a matrix.\nres should have ntotal rows\nres should have ntotal columns\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_bandMulMatVec-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, Integer, Integer, Integer, Integer, Union{Bool, UInt8}}","page":"API","title":"MuJoCo.mju_bandMulMatVec","text":"mju_bandMulMatVec(res, mat, vec, ntotal, nband, ndense, nVec, flg_sym)\n\nMultiply band-diagonal matrix with nvec vectors, include upper triangle if flg_sym>0.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nvec::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nntotal::Int32\nnband::Int32\nndense::Int32\nnVec::Int32\nflg_sym::UInt8\n\nAdditional Info\n\nres should be a vector, not a matrix.\nres should have ntotal rows\nres should have nVec columns\nvec should have ntotal rows\nvec should have nVec columns\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_boxQP-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, Union{Nothing, AbstractVecOrMat{Int32}}, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}, Union{Nothing, AbstractVecOrMat{Float64}}, Union{Nothing, AbstractVecOrMat{Float64}}}","page":"API","title":"MuJoCo.mju_boxQP","text":"mju_boxQP(res, R, index, H, g, lower, upper)\n\nminimize 0.5x'Hx + x'g  s.t. lower <= x <= upper, return rank or -1 if failed   inputs:     n           - problem dimension     H           - SPD matrix                nn     g           - bias vector               n     lower       - lower bounds              n     upper       - upper bounds              n     res         - solution warmstart        n   return value:     nfree <= n  - rank of unconstrained subspace, -1 if failure   outputs (required):     res         - solution                  n     R           - subspace Cholesky factor  nfreenfree    allocated: n(n+7)   outputs (optional):     index       - set of free dimensions    nfree          allocated: n   notes:     the initial value of res is used to warmstart the solver     R must have allocatd size n(n+7), but only nfree*nfree values are used in output     index (if given) must have allocated size n, but only nfree values are used in output     only the lower triangles of H and R and are read from and written to, respectively     the convenience function mju_boxQPmalloc allocates the required data structures\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nR::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nindex::Vector{Int32} -> An optional vector of variable size. Check additional info for sizes.\nH::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\ng::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nlower::Vector{Float64} -> An optional vector of variable size. Check additional info for sizes. Constant.\nupper::Vector{Float64} -> An optional vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nindex should be a vector, not a matrix.\ng should be a vector, not a matrix.\nlower should be a vector, not a matrix.\nupper should be a vector, not a matrix.\nsize of R should be n*(n+7)\nsize of index should equal n\nH should be of shape (n, n)\nsize of g should equal n\nsize of lower should equal n\nsize of upper should equal n\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_cholFactor-Tuple{AbstractMatrix{Float64}, Real}","page":"API","title":"MuJoCo.mju_cholFactor","text":"mju_cholFactor(mat, mindiag)\n\nCholesky decomposition: mat = L*L'; return rank, decomposition performed in-place into mat.\n\nArguments\n\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmindiag::Float64\n\nAdditional Info\n\nmat should be a square matrix\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_cholFactorBand-Tuple{AbstractVecOrMat{Float64}, Integer, Integer, Integer, Real, Real}","page":"API","title":"MuJoCo.mju_cholFactorBand","text":"mju_cholFactorBand(mat, ntotal, nband, ndense, diagadd, diagmul)\n\nBand-dense Cholesky decomposition.  Returns minimum value in the factorized diagonal, or 0 if rank-deficient.  mat has (ntotal-ndense) x nband + ndense x ntotal elements.  The first (ntotal-ndense) x nband store the band part, left of diagonal, inclusive.  The second ndense x ntotal store the band part as entire dense rows.  Add diagadd+diagmul*mat_ii to diagonal before factorization.\n\nArguments\n\nmat::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nntotal::Int32\nnband::Int32\nndense::Int32\ndiagadd::Float64\ndiagmul::Float64\n\nAdditional Info\n\nmat should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_cholSolve-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_cholSolve","text":"mju_cholSolve(res, mat, vec)\n\nSolve (mat*mat') * res = vec, where mat is a Cholesky factor.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nmat should be a square matrix\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_cholSolveBand-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Integer, Integer, Integer}","page":"API","title":"MuJoCo.mju_cholSolveBand","text":"mju_cholSolveBand(res, mat, vec, ntotal, nband, ndense)\n\nSolve (matmat')res = vec where mat is a band-dense Cholesky factor.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nntotal::Int32\nnband::Int32\nndense::Int32\n\nAdditional Info\n\nres should be a vector, not a matrix.\nmat should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nsize of res should equal ntotal\nsize of vec should equal ntotal\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_cholUpdate-Tuple{AbstractMatrix{Float64}, AbstractVecOrMat{Float64}, Integer}","page":"API","title":"MuJoCo.mju_cholUpdate","text":"mju_cholUpdate(mat, x, flg_plus)\n\nCholesky rank-one update: LL' +/- xx'; return rank.\n\nArguments\n\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nx::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nflg_plus::Int32\n\nAdditional Info\n\nx should be a vector, not a matrix.\nmat should be a square matrix\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_copy-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_copy","text":"mju_copy(res, data)\n\nSet res = vec.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\ndata::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\ndata should be a vector, not a matrix.\nres and data should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_d2n-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_d2n","text":"mju_d2n(res, vec)\n\nConvert from double to mjtNum.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_decodePyramid-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_decodePyramid","text":"mju_decodePyramid(force, pyramid, mu)\n\nConvert pyramid representation to contact force.\n\nArguments\n\nforce::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\npyramid::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nmu::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nforce should be a vector, not a matrix.\npyramid should be a vector, not a matrix.\nmu should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_dense2Band-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, Integer, Integer, Integer}","page":"API","title":"MuJoCo.mju_dense2Band","text":"mju_dense2Band(res, mat, ntotal, nband, ndense)\n\nConvert dense matrix to banded matrix.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nntotal::Int32\nnband::Int32\nndense::Int32\n\nAdditional Info\n\nres should be a vector, not a matrix.\nmat should have ntotal rows\nmat should have ntotal columns\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_dot-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_dot","text":"mju_dot(vec1, vec2)\n\nReturn dot-product of vec1 and vec2.\n\nArguments\n\nvec1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nvec2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nvec1 should be a vector, not a matrix.\nvec2 should be a vector, not a matrix.\nvec1 and vec2 should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_encodePyramid-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_encodePyramid","text":"mju_encodePyramid(pyramid, force, mu)\n\nConvert contact force to pyramid representation.\n\nArguments\n\npyramid::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nforce::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nmu::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\npyramid should be a vector, not a matrix.\nforce should be a vector, not a matrix.\nmu should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_eye-Tuple{AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_eye","text":"mju_eye(mat)\n\nSet mat to the identity matrix.\n\nArguments\n\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\n\nAdditional Info\n\nmat should be square\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_f2n-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float32}}","page":"API","title":"MuJoCo.mju_f2n","text":"mju_f2n(res, vec)\n\nConvert from float to mjtNum.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float32} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_fill-Tuple{AbstractVecOrMat{Float64}, Real}","page":"API","title":"MuJoCo.mju_fill","text":"mju_fill(res, val)\n\nSet res = val.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nval::Float64\n\nAdditional Info\n\nres should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_insertionSort-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_insertionSort","text":"mju_insertionSort(res)\n\nInsertion sort, resulting list is in increasing order.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nres should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_insertionSortInt-Tuple{AbstractVecOrMat{Int32}}","page":"API","title":"MuJoCo.mju_insertionSortInt","text":"mju_insertionSortInt(res)\n\nInteger insertion sort, resulting list is in increasing order.\n\nArguments\n\nres::Vector{Int32} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nres should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_isZero-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_isZero","text":"mju_isZero(vec)\n\nReturn 1 if all elements are 0.\n\nArguments\n\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulMatMat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_mulMatMat","text":"mju_mulMatMat(res, mat1, mat2)\n\nMultiply matrices: res = mat1 * mat2.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat1::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nmat2::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\n#rows in res should equal #rows in mat1\n#columns in mat1 should equal #rows in mat2\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulMatMatT-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_mulMatMatT","text":"mju_mulMatMatT(res, mat1, mat2)\n\nMultiply matrices, second argument transposed: res = mat1 * mat2'.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat1::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nmat2::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\n#rows in res should equal #rows in mat1\n#columns in res should equal #rows in mat2\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulMatTMat-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_mulMatTMat","text":"mju_mulMatTMat(res, mat1, mat2)\n\nMultiply matrices, first argument transposed: res = mat1' * mat2.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat1::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nmat2::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\n#rows in res should equal #columns in mat1\n#rows in mat1 should equal #rows in mat2\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulMatTVec-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_mulMatTVec","text":"mju_mulMatTVec(res, mat, vec)\n\nMultiply transposed matrix and vector: res = mat' * vec.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulMatVec-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_mulMatVec","text":"mju_mulMatVec(res, mat, vec)\n\nMultiply matrix and vector: res = mat * vec.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_mulVecMatVec-Tuple{AbstractVecOrMat{Float64}, AbstractMatrix{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_mulVecMatVec","text":"mju_mulVecMatVec(vec1, mat, vec2)\n\nMultiply square matrix with vectors on both sides: returns vec1' * mat * vec2.\n\nArguments\n\nvec1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\nvec2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nvec1 should be a vector, not a matrix.\nvec2 should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_n2d-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_n2d","text":"mju_n2d(res, vec)\n\nConvert from mjtNum to double.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_n2f-Tuple{AbstractVecOrMat{Float32}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_n2f","text":"mju_n2f(res, vec)\n\nConvert from mjtNum to float.\n\nArguments\n\nres::Vector{Float32} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_norm-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_norm","text":"mju_norm(vec)\n\nReturn vector length (without normalizing vector).\n\nArguments\n\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_normalize-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_normalize","text":"mju_normalize(vec)\n\nNormalize vector, return length before normalization.\n\nArguments\n\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_printMat-Tuple{AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_printMat","text":"mju_printMat(mat)\n\nPrint matrix to screen.\n\nArguments\n\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_scl-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, Real}","page":"API","title":"MuJoCo.mju_scl","text":"mju_scl(res, vec, scl)\n\nSet res = vec*scl.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nscl::Float64\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_sqrMatTD-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, Union{Nothing, AbstractVecOrMat{Float64}}}","page":"API","title":"MuJoCo.mju_sqrMatTD","text":"mju_sqrMatTD(res, mat, diag)\n\nSet res = mat' * diag * mat if diag is not NULL, and res = mat' * mat otherwise.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\ndiag::Vector{Float64} -> An optional vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\ndiag should be a vector, not a matrix.\n#rows in res should equal #columns in mat\n#rows in res should equal #columns in mat\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_sub-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_sub","text":"mju_sub(res, vec1, vec2)\n\nSet res = vec1 - vec2.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec1::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\nvec2::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec1 should be a vector, not a matrix.\nvec2 should be a vector, not a matrix.\nres and vec1 should have the same size\nres and vec2 should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_subFrom-Tuple{AbstractVecOrMat{Float64}, AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_subFrom","text":"mju_subFrom(res, vec)\n\nSet res = res - vec.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nres should be a vector, not a matrix.\nvec should be a vector, not a matrix.\nres and vec should have the same size\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_sum-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_sum","text":"mju_sum(vec)\n\nReturn sum(vec).\n\nArguments\n\nvec::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nvec should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_symmetrize-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_symmetrize","text":"mju_symmetrize(res, mat)\n\nSymmetrize square matrix res = (mat + mat')/2.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\nmat should be square\nres and mat should have the same shape\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_transpose-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}}","page":"API","title":"MuJoCo.mju_transpose","text":"mju_transpose(res, mat)\n\nTranspose matrix: res = mat'.\n\nArguments\n\nres::Matrix{Float64} -> A matrix variable size. Check additional info for sizes.\nmat::Matrix{Float64} -> A matrix variable size. Check additional info for sizes. Constant.\n\nAdditional Info\n\n#columns in res should equal #rows in mat\n#rows in res should equal #columns in mat\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.mju_zero-Tuple{AbstractVecOrMat{Float64}}","page":"API","title":"MuJoCo.mju_zero","text":"mju_zero(res)\n\nSet res = 0.\n\nArguments\n\nres::Vector{Float64} -> A vector of variable size. Check additional info for sizes.\n\nAdditional Info\n\nres should be a vector, not a matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.reset!-Tuple{Model, Data}","page":"API","title":"MuJoCo.reset!","text":"reset!(m::Model, d::Data)\n\nResets the data values to their default states. You may equivalently use mj_resetData.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.resetkey!-Tuple{Model, Data, Integer}","page":"API","title":"MuJoCo.resetkey!","text":"resetkey!(m::Model, d::Data, [keyframe = 1])\n\nResets the data struct to values in the supplied keyframe. \n\nIf no keyframe is specified, the first keyframe is used. The keyframe is a 1-based index into the list supplied by the model's specification.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.resetkey!-Tuple{Model, Data}","page":"API","title":"MuJoCo.resetkey!","text":"Resets the data struct to values in the first key frame.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.sample_model_and_data-Tuple{}","page":"API","title":"MuJoCo.sample_model_and_data","text":"sample_model_and_data()\n\nA utility module to create and initialise example Model and Data objects, reflecting the underlying mjModel and mjData structs to provide REPL code completition to aid development.\n\nReturns a (model, data) tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.set_physics_state!-Tuple{Model, Data, AbstractVector}","page":"API","title":"MuJoCo.set_physics_state!","text":"set_physics_state!(m::Model, d::Data, x::AbstractVector)\n\nSet the state vector of a MuJoCo model.\n\nThe state vector is [joint positions, joint velocities, actuator states] with dimension (nq, nv, na). Call forward! after setting the state to compute all derived quantities in the Data object according to the new state.\n\nSee also mj_setState and get_physics_state.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.step!-Tuple{Union{MuJoCo.Wrappers.NamedAccess.NamedModel, Model}, Union{MuJoCo.Wrappers.NamedAccess.NamedData, Data}}","page":"API","title":"MuJoCo.step!","text":"step!(model::Model, data::Data)\n\nRuns the simulation forward one time step, modifying the underlying data object.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#MuJoCo.timestep-Tuple{Union{MuJoCo.Wrappers.NamedAccess.NamedModel, Model}}","page":"API","title":"MuJoCo.timestep","text":"timestep(model::MODEL_TYPES)\n\nExtract the solver time-step for the given model.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#Visualiser","page":"API","title":"Visualiser","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo.Visualiser]","category":"page"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo.Visualiser]","category":"page"},{"location":"library/api/#MuJoCo.Visualiser.visualise!","page":"API","title":"MuJoCo.Visualiser.visualise!","text":"visualise!(m::Model, d::Data; controller=nothing, trajectories=nothing)\n\nStarts an interactive visualization of a MuJoCo model specified by an instance of Model and Data.\n\nThe visualizer has three \"modes\" that allow you to visualize passive dynamics, run a controller interactively, or play back recorded trajectories. The passive dynamics mode is always available, while the controller and trajectory modes are specified by the keyword arguments below.\n\nPress F1 for help after running the visualiser to print the available mouse/button options in the terminal. Switch between modes with CTRL+RightArrow and CTRL+LeftArrow (or CMD for Mac). The different visualiser modes are ordered as follows:\n\nController mode (if controller keyword is provided)\nTrajectory mode (if trajectories keyword is provided)\nPassive mode (always available)\n\nKeywords\n\ncontroller: a callback function with the signature controller(m, d), called at each timestep, that applies a control input to the system (or does any other operation you like).\ntrajectories: a single trajectory or Vector of trajectories, where each trajectory is an AbstractMatrix of states with size (nx, T) where nx = model.nq + model.nv + model.na and T is the length of the trajectory. Note that each trajectory can have a different length.\n\nExamples\n\nusing MuJoCo\ninstall_visualiser() # Run this to install dependencies only once\ninit_visualiser()    # Load required dependencies into session\n\n# Load a model\nmodel, data = MuJoCo.sample_model_and_data()\n\n# Simulate and record a trajectory\nT = 200\nnx = model.nq + model.nv + model.na\nstates = zeros(nx, T)\nfor t in 1:T\n    states[:,t] = get_physics_state(model, data)\n    step!(model, data)\nend\n\n# Define a controller\nfunction ctrl!(m,d)\n    d.ctrl .= 2*rand(m.nu) .- 1\nend\n\n# Run the visualiser\nreset!(model, data)\nvisualise!(model, data, controller=ctrl!, trajectories = states)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#Named-Access","page":"API","title":"Named Access","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo.NamedAccess]","category":"page"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [MuJoCo.NamedAccess]","category":"page"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.actuator","page":"API","title":"MuJoCo.Wrappers.NamedAccess.actuator","text":"actuator([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, ctrl, length, moment, velocity, force)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.body","page":"API","title":"MuJoCo.Wrappers.NamedAccess.body","text":"body([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, applied, xpos, xquat, xmat, xipos, ximat, com, cinert, crb, cvel, linvel, angmom, cacc, int, ext)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.cam","page":"API","title":"MuJoCo.Wrappers.NamedAccess.cam","text":"cam([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, xpos, xmat)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.eq","page":"API","title":"MuJoCo.Wrappers.NamedAccess.eq","text":"eq([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, type, obj1id, obj2id, active, solref, solimp, data)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.exclude","page":"API","title":"MuJoCo.Wrappers.NamedAccess.exclude","text":"exclude([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, signature)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.geom","page":"API","title":"MuJoCo.Wrappers.NamedAccess.geom","text":"geom([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, xpos, xmat)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.hfield","page":"API","title":"MuJoCo.Wrappers.NamedAccess.hfield","text":"hfield([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, size, nrow, ncol, adr)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.jnt","page":"API","title":"MuJoCo.Wrappers.NamedAccess.jnt","text":"jnt([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, xanchor, xaxis)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.key","page":"API","title":"MuJoCo.Wrappers.NamedAccess.key","text":"key([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, time, qpos, qvel, act, mpos, mquat)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.light","page":"API","title":"MuJoCo.Wrappers.NamedAccess.light","text":"light([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, xpos, xdir)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.mat","page":"API","title":"MuJoCo.Wrappers.NamedAccess.mat","text":"mat([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, texid, texuniform, texrepeat, emission, specular, shininess, reflectance, rgba)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.mesh","page":"API","title":"MuJoCo.Wrappers.NamedAccess.mesh","text":"mesh([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, vertadr, vertnum, texcoordadr, faceadr, facenum, graphadr)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.numeric","page":"API","title":"MuJoCo.Wrappers.NamedAccess.numeric","text":"numeric([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, adr, size)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.pair","page":"API","title":"MuJoCo.Wrappers.NamedAccess.pair","text":"pair([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, dim, geom1, geom2, signature, solref, solimp, margin, gap, friction)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.sensor","page":"API","title":"MuJoCo.Wrappers.NamedAccess.sensor","text":"sensor([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.site","page":"API","title":"MuJoCo.Wrappers.NamedAccess.site","text":"site([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, xpos, xmat)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.skin","page":"API","title":"MuJoCo.Wrappers.NamedAccess.skin","text":"skin([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, matid, rgba, inflate, vertadr, vertnum, texcoordadr, faceadr, facenum, boneadr, bonenum)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.tendon","page":"API","title":"MuJoCo.Wrappers.NamedAccess.tendon","text":"tendon([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, wrapadr, wrapnum, Jrownnz, Jrowadr, J_colind, length, J, velocity)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.tex","page":"API","title":"MuJoCo.Wrappers.NamedAccess.tex","text":"tex([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, type, height, width, adr)\n\n\n\n\n\n","category":"function"},{"location":"library/api/#MuJoCo.Wrappers.NamedAccess.tuple","page":"API","title":"MuJoCo.Wrappers.NamedAccess.tuple","text":"tuple([model, data], [name, index])\n\nCreates an object with access to views of the supplied model or data object, based either on an index or a name. Index refers to MuJoCo IDs, which start at 0. Properties available are: (id, name, adr, size)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MuJoCo","category":"page"},{"location":"#MuJoCo.jl-Documentation","page":"Home","title":"MuJoCo.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MuJoCo.jl, a wrapper for DeepMind's MuJoCo library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for MuJoCo.jl. This package contains a Julia wrapper for  DeepMind's general-purpose physics engine, allowing users to simulate robotic systems, their controllers, and their interactions with surrounding environments, all in native Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This wrapper aims to provide a simple, performant interface to the MuJoCo C library, allowing direct manipulation of the data used by the C engine for optimal performance. See the MuJoCo API page for our wrapped functions. We also provide a thin wrapper directly around the MuJoCo C library, which directly wraps all functions exported by the libmujoco.h header file. You can view the structs and functions available in the LibMuJoCo Index page.","category":"page"},{"location":"#Version","page":"Home","title":"Version","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The version of MuJoCo this package uses is always made to match the version of MuJoCo_jll, checked via","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.status(\"MuJoCo_jll\"; mode=Pkg.PKGMODE_MANIFEST)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started\nPackage Overview","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Balancing a Cart-Pole\nHumanoid LQR","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributing to the Package","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MuJoCo API\nLibMuJoCo Index\nLibMuJoCo API","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much of this project builds upon the work from Lyceum and their package Lyceum/MuJoCo.jl, along with their visualisation project LyceumMuJoCoViz. We would like to thank the authors of these packages for their amazing work in originally bringing MuJoCo to Julia.","category":"page"},{"location":"library/libmujoco/#LibMuJoCo-API","page":"API","title":"LibMuJoCo API","text":"","category":"section"},{"location":"library/libmujoco/","page":"API","title":"API","text":"Auto-generated bindings for the MuJoCo C library.","category":"page"},{"location":"library/libmujoco/","page":"API","title":"API","text":"Modules = [MuJoCo.LibMuJoCo]","category":"page"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjContact_","page":"API","title":"MuJoCo.LibMuJoCo.mjContact_","text":"mjContact\n\nFields\n\ndist: distance between nearest points; neg: penetration\npos: position of contact point: midpoint between geoms\nframe: normal is in [0-2]\nincludemargin: include if dist<includemargin=margin-gap\nfriction: tangent1, 2, spin, roll1, 2\nsolref: constraint solver reference, normal direction\nsolreffriction: constraint solver reference, friction directions\nsolimp: constraint solver impedance\nmu: friction of regularized cone, set by mj_makeConstraint\nH: cone Hessian, set by mj_updateConstraint\ndim: contact space dimensionality: 1, 3, 4 or 6\ngeom1: id of geom 1\ngeom2: id of geom 2\nexclude: 0: include, 1: in gap, 2: fused, 3: no dofs\nefc_address: address in efc; -1: not included\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjData_","page":"API","title":"MuJoCo.LibMuJoCo.mjData_","text":"mjData\n\nFields\n\nnstack: number of mjtNums that can fit in the arena+stack space\nnbuffer: size of main buffer in bytes\nnplugin: number of plugin instances\npstack: first available mjtNum address in stack\nparena: first available byte in arena\nmaxuse_stack: maximum stack allocation\nmaxuse_arena: maximum arena allocation\nmaxuse_con: maximum number of contacts\nmaxuse_efc: maximum number of scalar constraints\nwarning: warning statistics\ntimer: timer statistics\nsolver: solver statistics per iteration\nsolver_iter: number of solver iterations\nsolver_nnz: number of non-zeros in Hessian or efc_AR\nsolver_fwdinv: forward-inverse comparison: qfrc, efc\nnbodypair_broad: number of body pairs in collision according to the broad-phase\nnbodypair_narrow: number of body pairs actually in collision in the narrow-phase\nngeompair_mid: number of geom pairs in collision according to the mid-phase\nngeompair_narrow: number of geom pairs actually in collision in the narrow-phase\nne: number of equality constraints\nnf: number of friction constraints\nnefc: number of constraints\nnnzJ: number of non-zeros in constraint Jacobian\nncon: number of detected contacts\ntime: simulation time\nenergy: potential, kinetic energy\nbuffer: main buffer; all pointers point in it                (nbuffer bytes)\narena: arena+stack buffer                     (nstack*sizeof(mjtNum) bytes)\nqpos: position                                         (nq x 1)\nqvel: velocity                                         (nv x 1)\nact: actuator activation                              (na x 1)\nqacc_warmstart: acceleration used for warmstart                  (nv x 1)\nplugin_state: plugin state                                     (npluginstate x 1)\nctrl: control                                          (nu x 1)\nqfrc_applied: applied generalized force                        (nv x 1)\nxfrc_applied: applied Cartesian force/torque                   (nbody x 6)\nmocap_pos: positions of mocap bodies                        (nmocap x 3)\nmocap_quat: orientations of mocap bodies                     (nmocap x 4)\nqacc: acceleration                                     (nv x 1)\nact_dot: time-derivative of actuator activation           (na x 1)\nuserdata: user data, not touched by engine                 (nuserdata x 1)\nsensordata: sensor data array                                (nsensordata x 1)\nplugin: copy of m->plugin, required for deletion         (nplugin x 1)\nplugin_data: pointer to plugin-managed data structure         (nplugin x 1)\nxpos: Cartesian position of body frame                 (nbody x 3)\nxquat: Cartesian orientation of body frame              (nbody x 4)\nxmat: Cartesian orientation of body frame              (nbody x 9)\nxipos: Cartesian position of body com                   (nbody x 3)\nximat: Cartesian orientation of body inertia            (nbody x 9)\nxanchor: Cartesian position of joint anchor               (njnt x 3)\nxaxis: Cartesian joint axis                             (njnt x 3)\ngeom_xpos: Cartesian geom position                          (ngeom x 3)\ngeom_xmat: Cartesian geom orientation                       (ngeom x 9)\nsite_xpos: Cartesian site position                          (nsite x 3)\nsite_xmat: Cartesian site orientation                       (nsite x 9)\ncam_xpos: Cartesian camera position                        (ncam x 3)\ncam_xmat: Cartesian camera orientation                     (ncam x 9)\nlight_xpos: Cartesian light position                         (nlight x 3)\nlight_xdir: Cartesian light direction                        (nlight x 3)\nsubtree_com: center of mass of each subtree                   (nbody x 3)\ncdof: com-based motion axis of each dof                (nv x 6)\ncinert: com-based body inertia and mass                  (nbody x 10)\nten_wrapadr: start address of tendon's path                   (ntendon x 1)\nten_wrapnum: number of wrap points in path                    (ntendon x 1)\nten_J_rownnz: number of non-zeros in Jacobian row              (ntendon x 1)\nten_J_rowadr: row start address in colind array                (ntendon x 1)\nten_J_colind: column indices in sparse Jacobian                (ntendon x nv)\nten_length: tendon lengths                                   (ntendon x 1)\nten_J: tendon Jacobian                                  (ntendon x nv)\nwrap_obj: geom id; -1: site; -2: pulley                    (nwrap*2 x 1)\nwrap_xpos: Cartesian 3D points in all path                  (nwrap*2 x 3)\nactuator_length: actuator lengths                                 (nu x 1)\nactuator_moment: actuator moments                                 (nu x nv)\ncrb: com-based composite inertia and mass             (nbody x 10)\nqM: total inertia (sparse)                           (nM x 1)\nqLD: L'DL factorization of M (sparse)               (nM x 1)\nqLDiagInv: 1/diag(D)                                        (nv x 1)\nqLDiagSqrtInv: 1/sqrt(diag(D))                                  (nv x 1)\nbvh_active: volume has been added to collisions              (nbvh x 1)\nten_velocity: tendon velocities                                (ntendon x 1)\nactuator_velocity: actuator velocities                              (nu x 1)\ncvel: com-based velocity 3D rot; 3D tran\ncdof_dot: time-derivative of cdof                          (nv x 6)\nqfrc_bias: C(qpos,qvel)                                     (nv x 1)\nqfrc_passive: passive force                                    (nv x 1)\nefc_vel: velocity in constraint space: J*qvel             (nefc x 1)\nefc_aref: reference pseudo-acceleration                    (nefc x 1)\nsubtree_linvel: linear velocity of subtree com                   (nbody x 3)\nsubtree_angmom: angular momentum about subtree com               (nbody x 3)\nqH: L'DL factorization of modified M               (nM x 1)\nqHDiagInv: 1/diag(D) of modified M                          (nv x 1)\nD_rownnz: non-zeros in each row                            (nv x 1)\nD_rowadr: address of each row in D_colind                  (nv x 1)\nD_colind: column indices of non-zeros                      (nD x 1)\nB_rownnz: non-zeros in each row                            (nbody x 1)\nB_rowadr: address of each row in B_colind                  (nbody x 1)\nB_colind: column indices of non-zeros                      (nB x 1)\nqDeriv: d (passive + actuator - bias) / d qvel           (nD x 1)\nqLU: sparse LU of (qM - dt*qDeriv)                    (nD x 1)\nactuator_force: actuator force in actuation space                (nu x 1)\nqfrc_actuator: actuator force                                   (nv x 1)\nqfrc_smooth: net unconstrained force                          (nv x 1)\nqacc_smooth: unconstrained acceleration                       (nv x 1)\nqfrc_constraint: constraint force                                 (nv x 1)\nqfrc_inverse: net external force; should equal:                (nv x 1)qfrcapplied + J'*xfrcapplied + qfrc_actuator\ncacc: com-based acceleration                           (nbody x 6)\ncfrc_int: com-based interaction force with parent          (nbody x 6)\ncfrc_ext: com-based external force on body                 (nbody x 6)\ncontact: list of all detected contacts                    (ncon x 1)\nefc_type: constraint type (mjtConstraint)                  (nefc x 1)\nefc_id: id of object of specified type                   (nefc x 1)\nefc_J_rownnz: number of non-zeros in constraint Jacobian row   (nefc x 1)\nefc_J_rowadr: row start address in colind array                (nefc x 1)\nefc_J_rowsuper: number of subsequent rows in supernode           (nefc x 1)\nefc_J_colind: column indices in constraint Jacobian            (nnzJ x 1)\nefc_JT_rownnz: number of non-zeros in constraint Jacobian row T (nv x 1)\nefc_JT_rowadr: row start address in colind array              T (nv x 1)\nefc_JT_rowsuper: number of subsequent rows in supernode         T (nv x 1)\nefc_JT_colind: column indices in constraint Jacobian          T (nnzJ x 1)\nefc_J: constraint Jacobian                              (nnzJ x 1)\nefc_JT: constraint Jacobian transposed                   (nnzJ x 1)\nefc_pos: constraint position (equality, contact)          (nefc x 1)\nefc_margin: inclusion margin (contact)                       (nefc x 1)\nefc_frictionloss: frictionloss (friction)                          (nefc x 1)\nefc_diagApprox: approximation to diagonal of A                   (nefc x 1)\nefc_KBIP: stiffness, damping, impedance, imp'              (nefc x 4)\nefc_D: constraint mass                                  (nefc x 1)\nefc_R: inverse constraint mass                          (nefc x 1)\nefc_b: linear cost term: J*qacc_smooth - aref            (nefc x 1)\nefc_force: constraint force in constraint space              (nefc x 1)\nefc_state: constraint state (mjtConstraintState)             (nefc x 1)\nefc_AR_rownnz: number of non-zeros in AR                         (nefc x 1)\nefc_AR_rowadr: row start address in colind array                 (nefc x 1)\nefc_AR_colind: column indices in sparse AR                       (nefc x nefc)\nefc_AR: Jinv(M)J' + R                                   (nefc x nefc)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjLROpt_","page":"API","title":"MuJoCo.LibMuJoCo.mjLROpt_","text":"mjLROpt\n\nFields\n\nmode: which actuators to process (mjtLRMode)\nuseexisting: use existing length range if available\nuselimit: use joint and tendon limits if available\naccel: target acceleration used to compute force\nmaxforce: maximum force; 0: no limit\ntimeconst: time constant for velocity reduction; min 0.01\ntimestep: simulation timestep; 0: use mjOption.timestep\ninttotal: total simulation time interval\ninterval: evaluation time interval (at the end)\ntolrange: convergence tolerance (relative to range)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjModel_","page":"API","title":"MuJoCo.LibMuJoCo.mjModel_","text":"mjModel\n\nFields\n\nnq: number of generalized coordinates = dim(qpos)\nnv: number of degrees of freedom = dim(qvel)\nnu: number of actuators/controls = dim(ctrl)\nna: number of activation states = dim(act)\nnbody: number of bodies\nnbvh: number of total bounding volumes in all bodies\nnjnt: number of joints\nngeom: number of geoms\nnsite: number of sites\nncam: number of cameras\nnlight: number of lights\nnmesh: number of meshes\nnmeshvert: number of vertices in all meshes\nnmeshnormal: number of normals in all meshes\nnmeshtexcoord: number of texcoords in all meshes\nnmeshface: number of triangular faces in all meshes\nnmeshgraph: number of ints in mesh auxiliary data\nnskin: number of skins\nnskinvert: number of vertices in all skins\nnskintexvert: number of vertiex with texcoords in all skins\nnskinface: number of triangular faces in all skins\nnskinbone: number of bones in all skins\nnskinbonevert: number of vertices in all skin bones\nnhfield: number of heightfields\nnhfielddata: number of data points in all heightfields\nntex: number of textures\nntexdata: number of bytes in texture rgb data\nnmat: number of materials\nnpair: number of predefined geom pairs\nnexclude: number of excluded geom pairs\nneq: number of equality constraints\nntendon: number of tendons\nnwrap: number of wrap objects in all tendon paths\nnsensor: number of sensors\nnnumeric: number of numeric custom fields\nnnumericdata: number of mjtNums in all numeric fields\nntext: number of text custom fields\nntextdata: number of mjtBytes in all text fields\nntuple: number of tuple custom fields\nntupledata: number of objects in all tuple fields\nnkey: number of keyframes\nnmocap: number of mocap bodies\nnplugin: number of plugin instances\nnpluginattr: number of chars in all plugin config attributes\nnuser_body: number of mjtNums in body_user\nnuser_jnt: number of mjtNums in jnt_user\nnuser_geom: number of mjtNums in geom_user\nnuser_site: number of mjtNums in site_user\nnuser_cam: number of mjtNums in cam_user\nnuser_tendon: number of mjtNums in tendon_user\nnuser_actuator: number of mjtNums in actuator_user\nnuser_sensor: number of mjtNums in sensor_user\nnnames: number of chars in all names\nnnames_map: number of slots in the names hash map\nnM: number of non-zeros in sparse inertia matrix\nnD: number of non-zeros in sparse dof-dof matrix\nnB: number of non-zeros in sparse body-dof matrix\nnemax: number of potential equality-constraint rows\nnjmax: number of available rows in constraint Jacobian\nnconmax: number of potential contacts in contact list\nnstack: number of fields in mjData stack\nnuserdata: number of extra fields in mjData\nnsensordata: number of fields in sensor data vector\nnpluginstate: number of fields in the plugin state vector\nnbuffer: number of bytes in buffer\nopt: physics options\nvis: visualization options\nstat: model statistics\nbuffer: main buffer; all pointers point in it    (nbuffer)\nqpos0: qpos values at default pose              (nq x 1)\nqpos_spring: reference pose for springs               (nq x 1)\nbody_parentid: id of body's parent                      (nbody x 1)\nbody_rootid: id of root above body                    (nbody x 1)\nbody_weldid: id of body that this body is welded to   (nbody x 1)\nbody_mocapid: id of mocap data; -1: none               (nbody x 1)\nbody_jntnum: number of joints for this body           (nbody x 1)\nbody_jntadr: start addr of joints; -1: no joints      (nbody x 1)\nbody_dofnum: number of motion degrees of freedom      (nbody x 1)\nbody_dofadr: start addr of dofs; -1: no dofs          (nbody x 1)\nbody_geomnum: number of geoms                          (nbody x 1)\nbody_geomadr: start addr of geoms; -1: no geoms        (nbody x 1)\nbody_simple: body is simple (has diagonal M)          (nbody x 1)\nbody_sameframe: inertial frame is same as body frame     (nbody x 1)\nbody_pos: position offset rel. to parent body      (nbody x 3)\nbody_quat: orientation offset rel. to parent body   (nbody x 4)\nbody_ipos: local position of center of mass         (nbody x 3)\nbody_iquat: local orientation of inertia ellipsoid   (nbody x 4)\nbody_mass: mass                                     (nbody x 1)\nbody_subtreemass: mass of subtree starting at this body    (nbody x 1)\nbody_inertia: diagonal inertia in ipos/iquat frame     (nbody x 3)\nbody_invweight0: mean inv inert in qpos0 (trn, rot)       (nbody x 2)\nbody_gravcomp: antigravity force, units of body weight  (nbody x 1)\nbody_user: user data                                (nbody x nuser_body)\nbody_plugin: plugin instance id; -1: not in use       (nbody x 1)\nbody_bvhadr: address of bvh root                      (nbody x 1)\nbody_bvhnum: number of bounding volumes               (nbody x 1)\nbvh_depth: depth in the bounding volume hierarchy   (nbvh x 1)\nbvh_child: left and right children in tree          (nbvh x 2)\nbvh_geomid: geom id of the node; -1: non-leaf        (nbvh x 1)\nbvh_aabb: bounding box of node (center, size)      (nbvh x 6)\njnt_type: type of joint (mjtJoint)                 (njnt x 1)\njnt_qposadr: start addr in 'qpos' for joint's data    (njnt x 1)\njnt_dofadr: start addr in 'qvel' for joint's data    (njnt x 1)\njnt_bodyid: id of joint's body                       (njnt x 1)\njnt_group: group for visibility                     (njnt x 1)\njnt_limited: does joint have limits                   (njnt x 1)\njnt_actfrclimited: does joint have actuator force limits    (njnt x 1)\njnt_solref: constraint solver reference: limit       (njnt x mjNREF)\njnt_solimp: constraint solver impedance: limit       (njnt x mjNIMP)\njnt_pos: local anchor position                    (njnt x 3)\njnt_axis: local joint axis                         (njnt x 3)\njnt_stiffness: stiffness coefficient                    (njnt x 1)\njnt_range: joint limits                             (njnt x 2)\njnt_actfrcrange: range of total actuator force            (njnt x 2)\njnt_margin: min distance for limit detection         (njnt x 1)\njnt_user: user data                                (njnt x nuser_jnt)\ndof_bodyid: id of dof's body                         (nv x 1)\ndof_jntid: id of dof's joint                        (nv x 1)\ndof_parentid: id of dof's parent; -1: none             (nv x 1)\ndof_Madr: dof address in M-diagonal                (nv x 1)\ndof_simplenum: number of consecutive simple dofs        (nv x 1)\ndof_solref: constraint solver reference:frictionloss (nv x mjNREF)\ndof_solimp: constraint solver impedance:frictionloss (nv x mjNIMP)\ndof_frictionloss: dof friction loss                        (nv x 1)\ndof_armature: dof armature inertia/mass                (nv x 1)\ndof_damping: damping coefficient                      (nv x 1)\ndof_invweight0: diag. inverse inertia in qpos0           (nv x 1)\ndof_M0: diag. inertia in qpos0                   (nv x 1)\ngeom_type: geometric type (mjtGeom)                 (ngeom x 1)\ngeom_contype: geom contact type                        (ngeom x 1)\ngeom_conaffinity: geom contact affinity                    (ngeom x 1)\ngeom_condim: contact dimensionality (1, 3, 4, 6)      (ngeom x 1)\ngeom_bodyid: id of geom's body                        (ngeom x 1)\ngeom_dataid: id of geom's mesh/hfield; -1: none       (ngeom x 1)\ngeom_matid: material id for rendering; -1: none      (ngeom x 1)\ngeom_group: group for visibility                     (ngeom x 1)\ngeom_priority: geom contact priority                    (ngeom x 1)\ngeom_sameframe: same as body frame (1) or iframe (2)     (ngeom x 1)\ngeom_solmix: mixing coef for solref/imp in geom pair  (ngeom x 1)\ngeom_solref: constraint solver reference: contact     (ngeom x mjNREF)\ngeom_solimp: constraint solver impedance: contact     (ngeom x mjNIMP)\ngeom_size: geom-specific size parameters            (ngeom x 3)\ngeom_aabb: bounding box, (center, size)             (ngeom x 6)\ngeom_rbound: radius of bounding sphere                (ngeom x 1)\ngeom_pos: local position offset rel. to body       (ngeom x 3)\ngeom_quat: local orientation offset rel. to body    (ngeom x 4)\ngeom_friction: friction for (slide, spin, roll)         (ngeom x 3)\ngeom_margin: detect contact if dist<margin(ngeom x 1)\ngeom_gap: include in solver if dist<margin-gap     (ngeom x 1)\ngeom_fluid: fluid interaction parameters             (ngeom x mjNFLUID)\ngeom_user: user data                                (ngeom x nuser_geom)\ngeom_rgba: rgba when material is omitted            (ngeom x 4)\nsite_type: geom type for rendering (mjtGeom)        (nsite x 1)\nsite_bodyid: id of site's body                        (nsite x 1)\nsite_matid: material id for rendering; -1: none      (nsite x 1)\nsite_group: group for visibility                     (nsite x 1)\nsite_sameframe: same as body frame (1) or iframe (2)     (nsite x 1)\nsite_size: geom size for rendering                  (nsite x 3)\nsite_pos: local position offset rel. to body       (nsite x 3)\nsite_quat: local orientation offset rel. to body    (nsite x 4)\nsite_user: user data                                (nsite x nuser_site)\nsite_rgba: rgba when material is omitted            (nsite x 4)\ncam_mode: camera tracking mode (mjtCamLight)       (ncam x 1)\ncam_bodyid: id of camera's body                      (ncam x 1)\ncam_targetbodyid: id of targeted body; -1: none            (ncam x 1)\ncam_pos: position rel. to body frame              (ncam x 3)\ncam_quat: orientation rel. to body frame           (ncam x 4)\ncam_poscom0: global position rel. to sub-com in qpos0 (ncam x 3)\ncam_pos0: global position rel. to body in qpos0    (ncam x 3)\ncam_mat0: global orientation in qpos0              (ncam x 9)\ncam_fovy: y-field of view (deg)                    (ncam x 1)\ncam_ipd: inter-pupilary distance                  (ncam x 1)\ncam_user: user data                                (ncam x nuser_cam)\nlight_mode: light tracking mode (mjtCamLight)        (nlight x 1)\nlight_bodyid: id of light's body                       (nlight x 1)\nlight_targetbodyid: id of targeted body; -1: none            (nlight x 1)\nlight_directional: directional light                        (nlight x 1)\nlight_castshadow: does light cast shadows                  (nlight x 1)\nlight_active: is light on                              (nlight x 1)\nlight_pos: position rel. to body frame              (nlight x 3)\nlight_dir: direction rel. to body frame             (nlight x 3)\nlight_poscom0: global position rel. to sub-com in qpos0 (nlight x 3)\nlight_pos0: global position rel. to body in qpos0    (nlight x 3)\nlight_dir0: global direction in qpos0                (nlight x 3)\nlight_attenuation: OpenGL attenuation (quadratic model)     (nlight x 3)\nlight_cutoff: OpenGL cutoff                            (nlight x 1)\nlight_exponent: OpenGL exponent                          (nlight x 1)\nlight_ambient: ambient rgb (alpha=1)                    (nlight x 3)\nlight_diffuse: diffuse rgb (alpha=1)                    (nlight x 3)\nlight_specular: specular rgb (alpha=1)                   (nlight x 3)\nmesh_vertadr: first vertex address                     (nmesh x 1)\nmesh_vertnum: number of vertices                       (nmesh x 1)\nmesh_faceadr: first face address                       (nmesh x 1)\nmesh_facenum: number of faces                          (nmesh x 1)\nmesh_bvhadr: address of bvh root                      (nmesh x 1)\nmesh_bvhnum: number of bvh                            (nmesh x 1)\nmesh_normaladr: first normal address                     (nmesh x 1)\nmesh_normalnum: number of normals                        (nmesh x 1)\nmesh_texcoordadr: texcoord data address; -1: no texcoord   (nmesh x 1)\nmesh_texcoordnum: number of texcoord                       (nmesh x 1)\nmesh_graphadr: graph data address; -1: no graph         (nmesh x 1)\nmesh_vert: vertex positions for all meshes          (nmeshvert x 3)\nmesh_normal: normals for all meshes                   (nmeshnormal x 3)\nmesh_texcoord: vertex texcoords for all meshes          (nmeshtexcoord x 2)\nmesh_face: vertex face data                         (nmeshface x 3)\nmesh_facenormal: normal face data                         (nmeshface x 3)\nmesh_facetexcoord: texture face data                        (nmeshface x 3)\nmesh_graph: convex graph data                        (nmeshgraph x 1)\nskin_matid: skin material id; -1: none               (nskin x 1)\nskin_group: group for visibility                     (nskin x 1)\nskin_rgba: skin rgba                                (nskin x 4)\nskin_inflate: inflate skin in normal direction         (nskin x 1)\nskin_vertadr: first vertex address                     (nskin x 1)\nskin_vertnum: number of vertices                       (nskin x 1)\nskin_texcoordadr: texcoord data address; -1: no texcoord   (nskin x 1)\nskin_faceadr: first face address                       (nskin x 1)\nskin_facenum: number of faces                          (nskin x 1)\nskin_boneadr: first bone in skin                       (nskin x 1)\nskin_bonenum: number of bones in skin                  (nskin x 1)\nskin_vert: vertex positions for all skin meshes     (nskinvert x 3)\nskin_texcoord: vertex texcoords for all skin meshes     (nskintexvert x 2)\nskin_face: triangle faces for all skin meshes       (nskinface x 3)\nskin_bonevertadr: first vertex in each bone                (nskinbone x 1)\nskin_bonevertnum: number of vertices in each bone          (nskinbone x 1)\nskin_bonebindpos: bind pos of each bone                    (nskinbone x 3)\nskin_bonebindquat: bind quat of each bone                   (nskinbone x 4)\nskin_bonebodyid: body id of each bone                     (nskinbone x 1)\nskin_bonevertid: mesh ids of vertices in each bone        (nskinbonevert x 1)\nskin_bonevertweight: weights of vertices in each bone         (nskinbonevert x 1)\nhfield_size: (x, y, ztop, zbottom)                  (nhfield x 4)\nhfield_nrow: number of rows in grid                   (nhfield x 1)\nhfield_ncol: number of columns in grid                (nhfield x 1)\nhfield_adr: address in hfield_data                   (nhfield x 1)\nhfield_data: elevation data                           (nhfielddata x 1)\ntex_type: texture type (mjtTexture)                (ntex x 1)\ntex_height: number of rows in texture image          (ntex x 1)\ntex_width: number of columns in texture image       (ntex x 1)\ntex_adr: address in rgb                           (ntex x 1)\ntex_rgb: rgb (alpha = 1)                          (ntexdata x 1)\nmat_texid: texture id; -1: none                     (nmat x 1)\nmat_texuniform: make texture cube uniform                (nmat x 1)\nmat_texrepeat: texture repetition for 2d mapping        (nmat x 2)\nmat_emission: emission (x rgb)                         (nmat x 1)\nmat_specular: specular (x white)                       (nmat x 1)\nmat_shininess: shininess coef                           (nmat x 1)\nmat_reflectance: reflectance (0: disable)                 (nmat x 1)\nmat_rgba: rgba                                     (nmat x 4)\npair_dim: contact dimensionality                   (npair x 1)\npair_geom1: id of geom1                              (npair x 1)\npair_geom2: id of geom2                              (npair x 1)\npair_signature: (body1+1)<<16 + body2+1                (npair x 1)\npair_solref: solver reference: contact normal         (npair x mjNREF)\npair_solreffriction: solver reference: contact friction       (npair x mjNREF)\npair_solimp: solver impedance: contact                (npair x mjNIMP)\npair_margin: detect contact if dist<margin(npair x 1)\npair_gap: include in solver if dist<margin-gap     (npair x 1)\npair_friction: tangent1, 2, spin, roll1, 2              (npair x 5)\nexclude_signature: (body1+1)<<16 + body2+1                (nexclude x 1)\neq_type: constraint type (mjtEq)                  (neq x 1)\neq_obj1id: id of object 1                           (neq x 1)\neq_obj2id: id of object 2                           (neq x 1)\neq_active: enable/disable constraint                (neq x 1)\neq_solref: constraint solver reference              (neq x mjNREF)\neq_solimp: constraint solver impedance              (neq x mjNIMP)\neq_data: numeric data for constraint              (neq x mjNEQDATA)\ntendon_adr: address of first object in tendon's path (ntendon x 1)\ntendon_num: number of objects in tendon's path       (ntendon x 1)\ntendon_matid: material id for rendering                (ntendon x 1)\ntendon_group: group for visibility                     (ntendon x 1)\ntendon_limited: does tendon have length limits           (ntendon x 1)\ntendon_width: width for rendering                      (ntendon x 1)\ntendon_solref_lim: constraint solver reference: limit       (ntendon x mjNREF)\ntendon_solimp_lim: constraint solver impedance: limit       (ntendon x mjNIMP)\ntendon_solref_fri: constraint solver reference: friction    (ntendon x mjNREF)\ntendon_solimp_fri: constraint solver impedance: friction    (ntendon x mjNIMP)\ntendon_range: tendon length limits                     (ntendon x 2)\ntendon_margin: min distance for limit detection         (ntendon x 1)\ntendon_stiffness: stiffness coefficient                    (ntendon x 1)\ntendon_damping: damping coefficient                      (ntendon x 1)\ntendon_frictionloss: loss due to friction                     (ntendon x 1)\ntendon_lengthspring: spring resting length range              (ntendon x 2)\ntendon_length0: tendon length in qpos0                   (ntendon x 1)\ntendon_invweight0: inv. weight in qpos0                     (ntendon x 1)\ntendon_user: user data                                (ntendon x nuser_tendon)\ntendon_rgba: rgba when material is omitted            (ntendon x 4)\nwrap_type: wrap object type (mjtWrap)               (nwrap x 1)\nwrap_objid: object id: geom, site, joint             (nwrap x 1)\nwrap_prm: divisor, joint coef, or site id          (nwrap x 1)\nactuator_trntype: transmission type (mjtTrn)               (nu x 1)\nactuator_dyntype: dynamics type (mjtDyn)                   (nu x 1)\nactuator_gaintype: gain type (mjtGain)                      (nu x 1)\nactuator_biastype: bias type (mjtBias)                      (nu x 1)\nactuator_trnid: transmission id: joint, tendon, site     (nu x 2)\nactuator_actadr: first activation address; -1: stateless  (nu x 1)\nactuator_actnum: number of activation variables           (nu x 1)\nactuator_group: group for visibility                     (nu x 1)\nactuator_ctrllimited: is control limited                       (nu x 1)\nactuator_forcelimited: is force limited                         (nu x 1)\nactuator_actlimited: is activation limited                    (nu x 1)\nactuator_dynprm: dynamics parameters                      (nu x mjNDYN)\nactuator_gainprm: gain parameters                          (nu x mjNGAIN)\nactuator_biasprm: bias parameters                          (nu x mjNBIAS)\nactuator_ctrlrange: range of controls                        (nu x 2)\nactuator_forcerange: range of forces                          (nu x 2)\nactuator_actrange: range of activations                     (nu x 2)\nactuator_gear: scale length and transmitted force       (nu x 6)\nactuator_cranklength: crank length for slider-crank            (nu x 1)\nactuator_acc0: acceleration from unit force in qpos0    (nu x 1)\nactuator_length0: actuator length in qpos0                 (nu x 1)\nactuator_lengthrange: feasible actuator length range           (nu x 2)\nactuator_user: user data                                (nu x nuser_actuator)\nactuator_plugin: plugin instance id; -1: not a plugin     (nu x 1)\nsensor_type: sensor type (mjtSensor)                  (nsensor x 1)\nsensor_datatype: numeric data type (mjtDataType)          (nsensor x 1)\nsensor_needstage: required compute stage (mjtStage)        (nsensor x 1)\nsensor_objtype: type of sensorized object (mjtObj)       (nsensor x 1)\nsensor_objid: id of sensorized object                  (nsensor x 1)\nsensor_reftype: type of reference frame (mjtObj)         (nsensor x 1)\nsensor_refid: id of reference frame; -1: global frame  (nsensor x 1)\nsensor_dim: number of scalar outputs                 (nsensor x 1)\nsensor_adr: address in sensor array                  (nsensor x 1)\nsensor_cutoff: cutoff for real and positive; 0: ignore  (nsensor x 1)\nsensor_noise: noise standard deviation                 (nsensor x 1)\nsensor_user: user data                                (nsensor x nuser_sensor)\nsensor_plugin: plugin instance id; -1: not a plugin     (nsensor x 1)\nplugin: globally registered plugin slot number   (nplugin x 1)\nplugin_stateadr: address in the plugin state array        (nplugin x 1)\nplugin_statenum: number of states in the plugin instance  (nplugin x 1)\nplugin_attr: config attributes of plugin instances    (npluginattr x 1)\nplugin_attradr: address to each instance's config attrib (nplugin x 1)\nnumeric_adr: address of field in numeric_data         (nnumeric x 1)\nnumeric_size: size of numeric field                    (nnumeric x 1)\nnumeric_data: array of all numeric fields              (nnumericdata x 1)\ntext_adr: address of text in text_data             (ntext x 1)\ntext_size: size of text field (strlen+1)            (ntext x 1)\ntext_data: array of all text fields (0-terminated)  (ntextdata x 1)\ntuple_adr: address of text in text_data             (ntuple x 1)\ntuple_size: number of objects in tuple               (ntuple x 1)\ntuple_objtype: array of object types in all tuples      (ntupledata x 1)\ntuple_objid: array of object ids in all tuples        (ntupledata x 1)\ntuple_objprm: array of object params in all tuples     (ntupledata x 1)\nkey_time: key time                                 (nkey x 1)\nkey_qpos: key position                             (nkey x nq)\nkey_qvel: key velocity                             (nkey x nv)\nkey_act: key activation                           (nkey x na)\nkey_mpos: key mocap position                       (nkey x 3*nmocap)\nkey_mquat: key mocap quaternion                     (nkey x 4*nmocap)\nkey_ctrl: key control                              (nkey x nu)\nname_bodyadr: body name pointers                       (nbody x 1)\nname_jntadr: joint name pointers                      (njnt x 1)\nname_geomadr: geom name pointers                       (ngeom x 1)\nname_siteadr: site name pointers                       (nsite x 1)\nname_camadr: camera name pointers                     (ncam x 1)\nname_lightadr: light name pointers                      (nlight x 1)\nname_meshadr: mesh name pointers                       (nmesh x 1)\nname_skinadr: skin name pointers                       (nskin x 1)\nname_hfieldadr: hfield name pointers                     (nhfield x 1)\nname_texadr: texture name pointers                    (ntex x 1)\nname_matadr: material name pointers                   (nmat x 1)\nname_pairadr: geom pair name pointers                  (npair x 1)\nname_excludeadr: exclude name pointers                    (nexclude x 1)\nname_eqadr: equality constraint name pointers        (neq x 1)\nname_tendonadr: tendon name pointers                     (ntendon x 1)\nname_actuatoradr: actuator name pointers                   (nu x 1)\nname_sensoradr: sensor name pointers                     (nsensor x 1)\nname_numericadr: numeric name pointers                    (nnumeric x 1)\nname_textadr: text name pointers                       (ntext x 1)\nname_tupleadr: tuple name pointers                      (ntuple x 1)\nname_keyadr: keyframe name pointers                   (nkey x 1)\nname_pluginadr: plugin instance name pointers            (nplugin x 1)\nnames: names of all objects, 0-terminated       (nnames x 1)\nnames_map: internal hash map of names               (nnames_map x 1)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjOption_","page":"API","title":"MuJoCo.LibMuJoCo.mjOption_","text":"mjOption\n\nFields\n\ntimestep: timestep\napirate: update rate for remote API (Hz)\nimpratio: ratio of friction-to-normal contact impedance\ntolerance: main solver tolerance\nnoslip_tolerance: noslip solver tolerance\nmpr_tolerance: MPR solver tolerance\ngravity: gravitational acceleration\nwind: wind (for lift, drag and viscosity)\nmagnetic: global magnetic flux\ndensity: density of medium\nviscosity: viscosity of medium\no_margin: margin\no_solref: solref\no_solimp: solimp\nintegrator: integration mode (mjtIntegrator)\ncollision: collision mode (mjtCollision)\ncone: type of friction cone (mjtCone)\njacobian: type of Jacobian (mjtJacobian)\nsolver: solver algorithm (mjtSolver)\niterations: maximum number of main solver iterations\nnoslip_iterations: maximum number of noslip solver iterations\nmpr_iterations: maximum number of MPR solver iterations\ndisableflags: bit flags for disabling standard features\nenableflags: bit flags for enabling optional features\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjSolverStat_","page":"API","title":"MuJoCo.LibMuJoCo.mjSolverStat_","text":"mjSolverStat\n\nFields\n\nimprovement: cost reduction, scaled by 1/trace(M(qpos0))\ngradient: gradient norm (primal only, scaled)\nlineslope: slope in linesearch\nnactive: number of active constraints\nnchange: number of constraint state changes\nneval: number of cost evaluations in line search\nnupdate: number of Cholesky updates in line search\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjStatistic_","page":"API","title":"MuJoCo.LibMuJoCo.mjStatistic_","text":"mjStatistic\n\nFields\n\nmeaninertia: mean diagonal inertia\nmeanmass: mean body mass\nmeansize: mean body size\nextent: spatial extent\ncenter: center of model\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjTimerStat_","page":"API","title":"MuJoCo.LibMuJoCo.mjTimerStat_","text":"mjTimerStat\n\nFields\n\nduration: cumulative duration\nnumber: how many times was timer called\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjUI_","page":"API","title":"MuJoCo.LibMuJoCo.mjUI_","text":"mjUI\n\nFields\n\nspacing: UI theme spacing\ncolor: UI theme color\npredicate: callback to set item state programmatically\nuserdata: pointer to user data (passed to predicate)\nrectid: index of this ui rectangle in mjuiState\nauxid: aux buffer index of this ui\nradiocol: number of radio columns (0 defaults to 2)\nwidth: width\nheight: current heigth\nmaxheight: height when all sections open\nscroll: scroll from top of UI\nmousesect: 0: none, -1: scroll, otherwise 1+section\nmouseitem: item within section\nmousehelp: help button down: print shortcuts\neditsect: 0: none, otherwise 1+section\nedititem: item within section\neditcursor: cursor position\neditscroll: horizontal scroll\nedittext: current text\neditchanged: pointer to changed edit in last mjui_event\nnsect: number of sections in use\nsect: preallocated array of sections\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjVFS_","page":"API","title":"MuJoCo.LibMuJoCo.mjVFS_","text":"mjVFS\n\nFields\n\nnfile: number of files present\nfilename: file name without path\nfilesize: file size in bytes\nfiledata: buffer with file data\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjVisual_","page":"API","title":"MuJoCo.LibMuJoCo.mjVisual_","text":"mjVisual\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjWarningStat_","page":"API","title":"MuJoCo.LibMuJoCo.mjWarningStat_","text":"mjWarningStat\n\nFields\n\nlastinfo: info from last warning\nnumber: how many times was warning raised\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjrContext_","page":"API","title":"MuJoCo.LibMuJoCo.mjrContext_","text":"mjrContext\n\nFields\n\nlineWidth: line width for wireframe rendering\nshadowClip: clipping radius for directional lights\nshadowScale: fraction of light cutoff for spot lights\nfogStart: fog start = stat.extent * vis.map.fogstart\nfogEnd: fog end = stat.extent * vis.map.fogend\nfogRGBA: fog rgba\nshadowSize: size of shadow map texture\noffWidth: width of offscreen buffer\noffHeight: height of offscreen buffer\noffSamples: number of offscreen buffer multisamples\nfontScale: font scale\nauxWidth: auxiliary buffer width\nauxHeight: auxiliary buffer height\nauxSamples: auxiliary buffer multisamples\noffFBO: offscreen framebuffer object\noffFBO_r: offscreen framebuffer for resolving multisamples\noffColor: offscreen color buffer\noffColor_r: offscreen color buffer for resolving multisamples\noffDepthStencil: offscreen depth and stencil buffer\noffDepthStencil_r: offscreen depth and stencil buffer for resolving multisamples\nshadowFBO: shadow map framebuffer object\nshadowTex: shadow map texture\nauxFBO: auxiliary framebuffer object\nauxFBO_r: auxiliary framebuffer object for resolving\nauxColor: auxiliary color buffer\nauxColor_r: auxiliary color buffer for resolving\nntexture: number of allocated textures\ntextureType: type of texture (mjtTexture) (ntexture)\ntexture: texture names\nbasePlane: all planes from model\nbaseMesh: all meshes from model\nbaseHField: all hfields from model\nbaseBuiltin: all buildin geoms, with quality from model\nbaseFontNormal: normal font\nbaseFontShadow: shadow font\nbaseFontBig: big font\nrangePlane: all planes from model\nrangeMesh: all meshes from model\nrangeHField: all hfields from model\nrangeBuiltin: all builtin geoms, with quality from model\nrangeFont: all characters in font\nnskin: number of skins\nskinvertVBO: skin vertex position VBOs (nskin)\nskinnormalVBO: skin vertex normal VBOs (nskin)\nskintexcoordVBO: skin vertex texture coordinate VBOs (nskin)\nskinfaceVBO: skin face index VBOs (nskin)\ncharWidth: character widths: normal and shadow\ncharWidthBig: chacarter widths: big\ncharHeight: character heights: normal and shadow\ncharHeightBig: character heights: big\nglInitialized: is OpenGL initialized\nwindowAvailable: is default/window framebuffer available\nwindowSamples: number of samples for default/window framebuffer\nwindowStereo: is stereo available for default/window framebuffer\nwindowDoublebuffer: is default/window framebuffer double buffered\ncurrentBuffer: currently active framebuffer: mjFBWINDOW or mjFBOFFSCREEN\nreadPixelFormat: default color pixel format for mjr_readPixels\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjrRect_","page":"API","title":"MuJoCo.LibMuJoCo.mjrRect_","text":"mjrRect\n\nFields\n\nleft: left (usually 0)\nbottom: bottom (usually 0)\nwidth: width (usually buffer width)\nheight: height (usually buffer height)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiDef_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiDef_","text":"mjuiDef\n\nFields\n\ntype: type (mjtItem); -1: section\nname: name\nstate: state\npdata: pointer to data\nother: string with type-specific properties\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiItem_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiItem_","text":"mjuiItem\n\nFields\n\ntype: type (mjtItem)\nname: name\nstate: 0: disable, 1: enable, 2+: use predicate\npdata: data pointer (type-specific)\nsectionid: id of section containing item\nitemid: id of item within section\nrect: rectangle occupied by item\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiSection_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiSection_","text":"mjuiSection\n\nFields\n\nname: name\nstate: 0: closed, 1: open\nmodifier: 0: none, 1: control, 2: shift; 4: alt\nshortcut: shortcut key; 0: undefined\nnitem: number of items in use\nitem: preallocated array of items\nrtitle: rectangle occupied by title\nrcontent: rectangle occupied by content\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiState_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiState_","text":"mjuiState\n\nFields\n\nnrect: number of rectangles used\nrect: rectangles (index 0: entire window)\nuserdata: pointer to user data (for callbacks)\ntype: (type mjtEvent)\nleft: is left button down\nright: is right button down\nmiddle: is middle button down\ndoubleclick: is last press a double click\nbutton: which button was pressed (mjtButton)\nbuttontime: time of last button press\nx: x position\ny: y position\ndx: x displacement\ndy: y displacement\nsx: x scroll\nsy: y scroll\ncontrol: is control down\nshift: is shift down\nalt: is alt down\nkey: which key was pressed\nkeytime: time of last key press\nmouserect: which rectangle contains mouse\ndragrect: which rectangle is dragged with mouse\ndragbutton: which button started drag (mjtButton)\ndropcount: number of files dropped\ndroppaths: paths to files dropped\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiThemeColor_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiThemeColor_","text":"mjuiThemeColor\n\nFields\n\nmaster: master background\nthumb: scrollbar thumb\nsecttitle: section title\nsectfont: section font\nsectsymbol: section symbol\nsectpane: section pane\nshortcut: shortcut background\nfontactive: font active\nfontinactive: font inactive\ndecorinactive: decor inactive\ndecorinactive2: inactive slider color 2\nbutton: button\ncheck: check\nradio: radio\nselect: select\nselect2: select pane\nslider: slider\nslider2: slider color 2\nedit: edit\nedit2: edit invalid\ncursor: edit cursor\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjuiThemeSpacing_","page":"API","title":"MuJoCo.LibMuJoCo.mjuiThemeSpacing_","text":"mjuiThemeSpacing\n\nFields\n\ntotal: total width\nscroll: scrollbar width\nlabel: label width\nsection: section gap\nitemside: item side gap\nitemmid: item middle gap\nitemver: item vertical gap\ntexthor: text horizontal gap\ntextver: text vertical gap\nlinescroll: number of pixels to scroll\nsamples: number of multisamples\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvCamera_","page":"API","title":"MuJoCo.LibMuJoCo.mjvCamera_","text":"mjvCamera\n\nFields\n\ntype: camera type (mjtCamera)\nfixedcamid: fixed camera id\ntrackbodyid: body id to track\nlookat: lookat point\ndistance: distance to lookat point or tracked body\nazimuth: camera azimuth (deg)\nelevation: camera elevation (deg)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvFigure_","page":"API","title":"MuJoCo.LibMuJoCo.mjvFigure_","text":"mjvFigure\n\nFields\n\nflg_legend: show legend\nflg_ticklabel: show grid tick labels (x,y)\nflg_extend: automatically extend axis ranges to fit data\nflg_barplot: isolated line segments (i.e. GL_LINES)\nflg_selection: vertical selection line\nflg_symmetric: symmetric y-axis\nlinewidth: line width\ngridwidth: grid line width\ngridsize: number of grid points in (x,y)\ngridrgb: grid line rgb\nfigurergba: figure color and alpha\npanergba: pane color and alpha\nlegendrgba: legend color and alpha\ntextrgb: text color\nlinergb: line colors\nrange: axis ranges; (min>=max) automatic\nxformat: x-tick label format for sprintf\nyformat: y-tick label format for sprintf\nminwidth: string used to determine min y-tick width\ntitle: figure title; subplots separated with 2+ spaces\nxlabel: x-axis label\nlinename: line names for legend\nlegendoffset: number of lines to offset legend\nsubplot: selected subplot (for title rendering)\nhighlight: if point is in legend rect, highlight line\nhighlightid: if id>=0 and no point, highlight id\nselection: selection line x-value\nlinepnt: number of points in line; (0) disable\nlinedata: line data (x,y)\nxaxispixel: range of x-axis in pixels\nyaxispixel: range of y-axis in pixels\nxaxisdata: range of x-axis in data units\nyaxisdata: range of y-axis in data units\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvGLCamera_","page":"API","title":"MuJoCo.LibMuJoCo.mjvGLCamera_","text":"mjvGLCamera\n\nFields\n\npos: position\nforward: forward direction\nup: up direction\nfrustum_center: hor. center (left,right set to match aspect)\nfrustum_bottom: bottom\nfrustum_top: top\nfrustum_near: near\nfrustum_far: far\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvGeom_","page":"API","title":"MuJoCo.LibMuJoCo.mjvGeom_","text":"mjvGeom\n\nFields\n\ntype: geom type (mjtGeom)\ndataid: mesh, hfield or plane id; -1: none\nobjtype: mujoco object type; mjOBJ_UNKNOWN for decor\nobjid: mujoco object id; -1 for decor\ncategory: visual category\ntexid: texture id; -1: no texture\ntexuniform: uniform cube mapping\ntexcoord: mesh geom has texture coordinates\nsegid: segmentation id; -1: not shown\ntexrepeat: texture repetition for 2D mapping\nsize: size parameters\npos: Cartesian position\nmat: Cartesian orientation\nrgba: color and transparency\nemission: emission coef\nspecular: specular coef\nshininess: shininess coef\nreflectance: reflectance coef\nlabel: text label\ncamdist: distance to camera (used by sorter)\nmodelrbound: geom rbound from model, 0 if not model geom\ntransparent: treat geom as transparent\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvLight_","page":"API","title":"MuJoCo.LibMuJoCo.mjvLight_","text":"mjvLight\n\nFields\n\npos: position rel. to body frame\ndir: direction rel. to body frame\nattenuation: OpenGL attenuation (quadratic model)\ncutoff: OpenGL cutoff\nexponent: OpenGL exponent\nambient: ambient rgb (alpha=1)\ndiffuse: diffuse rgb (alpha=1)\nspecular: specular rgb (alpha=1)\nheadlight: headlight\ndirectional: directional light\ncastshadow: does light cast shadows\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvOption_","page":"API","title":"MuJoCo.LibMuJoCo.mjvOption_","text":"mjvOption\n\nFields\n\nlabel: what objects to label (mjtLabel)\nframe: which frame to show (mjtFrame)\ngeomgroup: geom visualization by group\nsitegroup: site visualization by group\njointgroup: joint visualization by group\ntendongroup: tendon visualization by group\nactuatorgroup: actuator visualization by group\nskingroup: skin visualization by group\nflags: visualization flags (indexed by mjtVisFlag)\nbvh_depth: depth of the bounding volume hierarchy to be visualized\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvPerturb_","page":"API","title":"MuJoCo.LibMuJoCo.mjvPerturb_","text":"mjvPerturb\n\nFields\n\nselect: selected body id; non-positive: none\nskinselect: selected skin id; negative: none\nactive: perturbation bitmask (mjtPertBit)\nactive2: secondary perturbation bitmask (mjtPertBit)\nrefpos: reference position for selected object\nrefquat: reference orientation for selected object\nrefselpos: reference position for selection point\nlocalpos: selection point in object coordinates\nlocalmass: spatial inertia at selection point\nscale: relative mouse motion-to-space scaling (set by initPerturb)\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvSceneState_","page":"API","title":"MuJoCo.LibMuJoCo.mjvSceneState_","text":"mjvSceneState\n\nFields\n\nnbuffer: size of the buffer in bytes\nbuffer: heap-allocated memory for all arrays in this struct\nmaxgeom: maximum number of mjvGeom supported by this state object\nplugincache: scratch space for vis geoms inserted by plugins\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjvScene_","page":"API","title":"MuJoCo.LibMuJoCo.mjvScene_","text":"mjvScene\n\nFields\n\nmaxgeom: size of allocated geom buffer\nngeom: number of geoms currently in buffer\ngeoms: buffer for geoms (ngeom)\ngeomorder: buffer for ordering geoms by distance to camera (ngeom)\nnskin: number of skins\nskinfacenum: number of faces in skin (nskin)\nskinvertadr: address of skin vertices (nskin)\nskinvertnum: number of vertices in skin (nskin)\nskinvert: skin vertex data (nskin)\nskinnormal: skin normal data (nskin)\nnlight: number of lights currently in buffer\nlights: buffer for lights (nlight)\ncamera: left and right camera\nenabletransform: enable model transformation\ntranslate: model translation\nrotate: model quaternion rotation\nscale: model scaling\nstereo: stereoscopic rendering (mjtStereo)\nflags: rendering flags (indexed by mjtRndFlag)\nframewidth: frame pixel width; 0: disable framing\nframergb: frame color\n\n\n\n\n\n","category":"type"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_Euler-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_Euler","text":"mj_Euler(m, d)\n\nEuler integrator, semi-implicit in velocity.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_RungeKutta-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_RungeKutta","text":"mj_RungeKutta(m, d, N)\n\nRunge-Kutta explicit order-N integrator.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_addContact-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_addContact","text":"mj_addContact(m, d, con)\n\nAdd contact to d->contact list; return 0 if success; 1 if buffer full.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_addFileVFS-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_addFileVFS","text":"mj_addFileVFS(vfs, directory, filename)\n\nAdd file to VFS, return 0: success, 1: full, 2: repeated name, -1: failed to load.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_addM-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_addM","text":"mj_addM(m, d, dst, rownnz, rowadr, colind)\n\nAdd inertia matrix to destination matrix. Destination can be sparse uncompressed, or dense when all int* are NULL\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_applyFT-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_applyFT","text":"mj_applyFT(m, d, force, torque, point, body, qfrc_target)\n\nApply Cartesian force and torque (outside xfrc_applied mechanism).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_camlight-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_camlight","text":"mj_camlight(m, d)\n\nCompute camera and light positions and orientations.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_checkAcc-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_checkAcc","text":"mj_checkAcc(m, d)\n\nCheck qacc, reset if any element is too big or nan.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_checkPos-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_checkPos","text":"mj_checkPos(m, d)\n\nCheck qpos, reset if any element is too big or nan.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_checkVel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_checkVel","text":"mj_checkVel(m, d)\n\nCheck qvel, reset if any element is too big or nan.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_collision-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_collision","text":"mj_collision(m, d)\n\nRun collision detection.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_comPos-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_comPos","text":"mj_comPos(m, d)\n\nMap inertias and motion dofs to global frame centered at CoM.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_comVel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_comVel","text":"mj_comVel(m, d)\n\nCompute cvel, cdof_dot.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_compareFwdInv-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_compareFwdInv","text":"mj_compareFwdInv(m, d)\n\nCompare forward and inverse dynamics, save results in fwdinv.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_constraintUpdate-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_constraintUpdate","text":"mj_constraintUpdate(m, d, jar, cost, flg_coneHessian)\n\nCompute efcstate, efcforce, qfrc_constraint, and (optionally) cone Hessians. If cost is not NULL, set cost = s(jar) where jar = Jacqacc-aref.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_contactForce-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_contactForce","text":"mj_contactForce(m, d, id, result)\n\nExtract 6D force:torque given contact id, in the contact frame.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_copyData-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_copyData","text":"mj_copyData(dest, m, src)\n\nCopy mjData. m is only required to contain the size fields from MJMODEL_INTS.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_copyModel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_copyModel","text":"mj_copyModel(dest, src)\n\nCopy mjModel, allocate new if dest is NULL.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_crb-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_crb","text":"mj_crb(m, d)\n\nRun composite rigid body inertia algorithm (CRB).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_defaultLROpt-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_defaultLROpt","text":"mj_defaultLROpt(opt)\n\nSet default options for length range computation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_defaultOption-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_defaultOption","text":"mj_defaultOption(opt)\n\nSet physics options to default values.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_defaultSolRefImp-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_defaultSolRefImp","text":"mj_defaultSolRefImp(solref, solimp)\n\nSet solver parameters to default values.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_defaultVFS-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_defaultVFS","text":"mj_defaultVFS(vfs)\n\nInitialize VFS to empty (no deallocation).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_defaultVisual-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_defaultVisual","text":"mj_defaultVisual(vis)\n\nSet visual options to default values.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_deleteData-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_deleteData","text":"mj_deleteData(d)\n\nFree memory allocation in mjData.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_deleteFileVFS-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_deleteFileVFS","text":"mj_deleteFileVFS(vfs, filename)\n\nDelete file from VFS, return 0: success, -1: not found in VFS.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_deleteModel-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_deleteModel","text":"mj_deleteModel(m)\n\nFree memory allocation in model.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_deleteVFS-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_deleteVFS","text":"mj_deleteVFS(vfs)\n\nDelete all files from VFS.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_differentiatePos-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_differentiatePos","text":"mj_differentiatePos(m, qvel, dt, qpos1, qpos2)\n\nCompute velocity by finite-differencing two positions.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_energyPos-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_energyPos","text":"mj_energyPos(m, d)\n\nEvaluate position-dependent energy (potential).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_energyVel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_energyVel","text":"mj_energyVel(m, d)\n\nEvaluate velocity-dependent energy (kinetic).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_factorM-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_factorM","text":"mj_factorM(m, d)\n\nCompute sparse L'DL factorizaton of inertia matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_findFileVFS-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_findFileVFS","text":"mj_findFileVFS(vfs, filename)\n\nReturn file index in VFS, or -1 if not found in VFS.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_forward-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_forward","text":"mj_forward(m, d)\n\nForward dynamics: same as mj_step but do not integrate in time.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_forwardSkip-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_forwardSkip","text":"mj_forwardSkip(m, d, skipstage, skipsensor)\n\nForward dynamics with skip; skipstage is mjtStage.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_freeLastXML-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mj_freeLastXML","text":"mj_freeLastXML()\n\nFree last XML model if loaded. Called internally at each load.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fullM-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fullM","text":"mj_fullM(m, dst, M)\n\nConvert sparse inertia matrix M into full (i.e. dense) matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fwdAcceleration-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fwdAcceleration","text":"mj_fwdAcceleration(m, d)\n\nAdd up all non-constraint forces, compute qacc_smooth.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fwdActuation-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fwdActuation","text":"mj_fwdActuation(m, d)\n\nCompute actuator force qfrc_actuator.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fwdConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fwdConstraint","text":"mj_fwdConstraint(m, d)\n\nRun selected constraint solver.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fwdPosition-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fwdPosition","text":"mj_fwdPosition(m, d)\n\nRun position-dependent computations.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_fwdVelocity-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_fwdVelocity","text":"mj_fwdVelocity(m, d)\n\nRun velocity-dependent computations.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_getPluginConfig-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_getPluginConfig","text":"mj_getPluginConfig(m, plugin_id, attrib)\n\nReturn a config attribute value of a plugin instance; NULL: invalid plugin instance ID or attribute name\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_getState-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_getState","text":"mj_getState(m, d, state, spec)\n\nGet state.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_getTotalmass-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_getTotalmass","text":"mj_getTotalmass(m)\n\nSum all body masses.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_id2name-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_id2name","text":"mj_id2name(m, type, id)\n\nGet name of object with the specified mjtObj type and id, returns NULL if name not found.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_integratePos-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_integratePos","text":"mj_integratePos(m, qpos, qvel, dt)\n\nIntegrate position with given velocity.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_invConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_invConstraint","text":"mj_invConstraint(m, d)\n\nApply the analytical formula for inverse constraint dynamics.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_invPosition-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_invPosition","text":"mj_invPosition(m, d)\n\nRun position-dependent computations in inverse dynamics.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_invVelocity-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_invVelocity","text":"mj_invVelocity(m, d)\n\nRun velocity-dependent computations in inverse dynamics.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_inverse-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_inverse","text":"mj_inverse(m, d)\n\nInverse dynamics: qacc must be set before calling.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_inverseSkip-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_inverseSkip","text":"mj_inverseSkip(m, d, skipstage, skipsensor)\n\nInverse dynamics with skip; skipstage is mjtStage.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_isDual-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_isDual","text":"mj_isDual(m)\n\nDetermine type of solver (PGS is dual, CG and Newton are primal).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_isPyramidal-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_isPyramidal","text":"mj_isPyramidal(m)\n\nDetermine type of friction cone.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_isSparse-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_isSparse","text":"mj_isSparse(m)\n\nDetermine type of constraint Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jac-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jac","text":"mj_jac(m, d, jacp, jacr, point, body)\n\nCompute 3/6-by-nv end-effector Jacobian of global point attached to given body.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacBody-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacBody","text":"mj_jacBody(m, d, jacp, jacr, body)\n\nCompute body frame end-effector Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacBodyCom-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacBodyCom","text":"mj_jacBodyCom(m, d, jacp, jacr, body)\n\nCompute body center-of-mass end-effector Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacGeom-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacGeom","text":"mj_jacGeom(m, d, jacp, jacr, geom)\n\nCompute geom end-effector Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacPointAxis-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacPointAxis","text":"mj_jacPointAxis(m, d, jacPoint, jacAxis, point, axis, body)\n\nCompute translation end-effector Jacobian of point, and rotation Jacobian of axis.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacSite-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacSite","text":"mj_jacSite(m, d, jacp, jacr, site)\n\nCompute site end-effector Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_jacSubtreeCom-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_jacSubtreeCom","text":"mj_jacSubtreeCom(m, d, jacp, body)\n\nCompute subtree center-of-mass end-effector Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_kinematics-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_kinematics","text":"mj_kinematics(m, d)\n\nRun forward kinematics.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_loadAllPluginLibraries-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_loadAllPluginLibraries","text":"mj_loadAllPluginLibraries(directory, callback)\n\nScan a directory and load all dynamic libraries. Dynamic libraries in the specified directory are assumed to register one or more plugins. Optionally, if a callback is specified, it is called for each dynamic library encountered that registers plugins.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_loadModel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_loadModel","text":"mj_loadModel(filename, vfs)\n\nLoad model from binary MJB file. If vfs is not NULL, look up file in vfs before reading from disk.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_loadPluginLibrary-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_loadPluginLibrary","text":"mj_loadPluginLibrary(path)\n\nLoad a dynamic library. The dynamic library is assumed to register one or more plugins.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_loadXML-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_loadXML","text":"mj_loadXML(filename, vfs, error, error_sz)\n\nParse XML file in MJCF or URDF format, compile it, return low-level model. If vfs is not NULL, look up files in vfs before reading from disk. If error is not NULL, it must have size error_sz.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_local2Global-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_local2Global","text":"mj_local2Global(d, xpos, xmat, pos, quat, body, sameframe)\n\nMap from body local to global Cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_makeConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_makeConstraint","text":"mj_makeConstraint(m, d)\n\nConstruct constraints.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_makeData-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_makeData","text":"mj_makeData(m)\n\nAllocate mjData corresponding to given model. If the model buffer is unallocated the initial configuration will not be set.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_makeEmptyFileVFS-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_makeEmptyFileVFS","text":"mj_makeEmptyFileVFS(vfs, filename, filesize)\n\nMake empty file in VFS, return 0: success, 1: full, 2: repeated name.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_mulJacTVec-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_mulJacTVec","text":"mj_mulJacTVec(m, d, res, vec)\n\nMultiply dense or sparse constraint Jacobian transpose by vector.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_mulJacVec-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_mulJacVec","text":"mj_mulJacVec(m, d, res, vec)\n\nMultiply dense or sparse constraint Jacobian by vector.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_mulM-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_mulM","text":"mj_mulM(m, d, res, vec)\n\nMultiply vector by inertia matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_mulM2-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_mulM2","text":"mj_mulM2(m, d, res, vec)\n\nMultiply vector by (inertia matrix)^(1/2).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_multiRay-NTuple{11, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_multiRay","text":"mj_multiRay(m, d, pnt, vec, geomgroup, flg_static, bodyexclude, geomid, dist, nray, cutoff)\n\nIntersect multiple rays emanating from a single point. Similar semantics to mj_ray, but vec is an array of (nray x 3) directions.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_name2id-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_name2id","text":"mj_name2id(m, type, name)\n\nGet id of object with the specified mjtObj type and name, returns -1 if id not found.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_normalizeQuat-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_normalizeQuat","text":"mj_normalizeQuat(m, qpos)\n\nNormalize all quaternions in qpos-type vector.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_objectAcceleration-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_objectAcceleration","text":"mj_objectAcceleration(m, d, objtype, objid, res, flg_local)\n\nCompute object 6D acceleration (rot:lin) in object-centered frame, world/local orientation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_objectVelocity-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_objectVelocity","text":"mj_objectVelocity(m, d, objtype, objid, res, flg_local)\n\nCompute object 6D velocity (rot:lin) in object-centered frame, world/local orientation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_passive-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_passive","text":"mj_passive(m, d)\n\nCompute qfrc_passive from spring-dampers, viscosity and density.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_printData-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_printData","text":"mj_printData(m, d, filename)\n\nPrint data to text file.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_printFormattedData-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_printFormattedData","text":"mj_printFormattedData(m, d, filename, float_format)\n\nPrint mjData to text file, specifying format. float_format must be a valid printf-style format string for a single float value\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_printFormattedModel-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_printFormattedModel","text":"mj_printFormattedModel(m, filename, float_format)\n\nPrint mjModel to text file, specifying format. float_format must be a valid printf-style format string for a single float value.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_printModel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_printModel","text":"mj_printModel(m, filename)\n\nPrint model to text file.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_printSchema-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_printSchema","text":"mj_printSchema(filename, buffer, buffer_sz, flg_html, flg_pad)\n\nPrint internal XML schema as plain text or HTML, with style-padding or &nbsp;.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_projectConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_projectConstraint","text":"mj_projectConstraint(m, d)\n\nCompute inverse constraint inertia efc_AR.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_ray-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_ray","text":"mj_ray(m, d, pnt, vec, geomgroup, flg_static, bodyexclude, geomid)\n\nIntersect ray (pnt+x*vec, x>=0) with visible geoms, except geoms in bodyexclude. Return distance (x) to nearest surface, or -1 if no intersection and output geomid. geomgroup, flg_static are as in mjvOption; geomgroup==NULL skips group exclusion.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_rayHfield-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_rayHfield","text":"mj_rayHfield(m, d, geomid, pnt, vec)\n\nIntersect ray with hfield, return nearest distance or -1 if no intersection.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_rayMesh-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_rayMesh","text":"mj_rayMesh(m, d, geomid, pnt, vec)\n\nIntersect ray with mesh, return nearest distance or -1 if no intersection.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_referenceConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_referenceConstraint","text":"mj_referenceConstraint(m, d)\n\nCompute efcvel, efcaref.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_resetCallbacks-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mj_resetCallbacks","text":"mj_resetCallbacks()\n\nReset all callbacks to NULL pointers (NULL is the default).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_resetData-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_resetData","text":"mj_resetData(m, d)\n\nReset data to defaults.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_resetDataDebug-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_resetDataDebug","text":"mj_resetDataDebug(m, d, debug_value)\n\nReset data to defaults, fill everything else with debug_value.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_resetDataKeyframe-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_resetDataKeyframe","text":"mj_resetDataKeyframe(m, d, key)\n\nReset data, set fields from specified keyframe.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_rne-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_rne","text":"mj_rne(m, d, flg_acc, result)\n\nRNE: compute M(qpos)*qacc + C(qpos,qvel); flg_acc=0 removes inertial term.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_rnePostConstraint-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_rnePostConstraint","text":"mj_rnePostConstraint(m, d)\n\nRNE with complete data: compute cacc, cfrcext, cfrcint.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_saveLastXML-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_saveLastXML","text":"mj_saveLastXML(filename, m, error, error_sz)\n\nUpdate XML data structures with info from low-level model, save as MJCF. If error is not NULL, it must have size error_sz.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_saveModel-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_saveModel","text":"mj_saveModel(m, filename, buffer, buffer_sz)\n\nSave model to binary MJB file or memory buffer; buffer has precedence when given.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_sensorAcc-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_sensorAcc","text":"mj_sensorAcc(m, d)\n\nEvaluate acceleration and force-dependent sensors.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_sensorPos-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_sensorPos","text":"mj_sensorPos(m, d)\n\nEvaluate position-dependent sensors.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_sensorVel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_sensorVel","text":"mj_sensorVel(m, d)\n\nEvaluate velocity-dependent sensors.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_setConst-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_setConst","text":"mj_setConst(m, d)\n\nSet constant fields of mjModel, corresponding to qpos0 configuration.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_setLengthRange-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_setLengthRange","text":"mj_setLengthRange(m, d, index, opt, error, error_sz)\n\nSet actuator_lengthrange for specified actuator; return 1 if ok, 0 if error.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_setState-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_setState","text":"mj_setState(m, d, state, spec)\n\nSet state.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_setTotalmass-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_setTotalmass","text":"mj_setTotalmass(m, newmass)\n\nScale body masses and inertias to achieve specified total mass.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_sizeModel-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_sizeModel","text":"mj_sizeModel(m)\n\nReturn size of buffer needed to hold model.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_solveM-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_solveM","text":"mj_solveM(m, d, x, y, n)\n\nSolve linear system M * x = y using factorization:  x = inv(L'DL)*y\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_solveM2-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_solveM2","text":"mj_solveM2(m, d, x, y, n)\n\nHalf of linear solve:  x = sqrt(inv(D))inv(L')y\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_stackAlloc-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_stackAlloc","text":"mj_stackAlloc(d, size)\n\nAllocate array of mjtNums on mjData stack. Call mju_error on stack overflow.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_stackAllocInt-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_stackAllocInt","text":"mj_stackAllocInt(d, size)\n\nAllocate array of ints on mjData stack. Call mju_error on stack overflow.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_stateSize-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_stateSize","text":"mj_stateSize(m, spec)\n\nReturn size of state specification.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_step-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_step","text":"mj_step(m, d)\n\nAdvance simulation, use control callback to obtain external force and control.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_step1-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_step1","text":"mj_step1(m, d)\n\nAdvance simulation in two steps: before external force and control is set by user.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_step2-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_step2","text":"mj_step2(m, d)\n\nAdvance simulation in two steps: after external force and control is set by user.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_subtreeVel-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_subtreeVel","text":"mj_subtreeVel(m, d)\n\nsubtree linear velocity and angular momentum\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_tendon-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_tendon","text":"mj_tendon(m, d)\n\nCompute tendon lengths, velocities and moment arms.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_transmission-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_transmission","text":"mj_transmission(m, d)\n\nCompute actuator transmission lengths and moments.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_version-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mj_version","text":"mj_version()\n\nReturn version number: 1.0.2 is encoded as 102.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_versionString-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mj_versionString","text":"mj_versionString()\n\nReturn the current version of MuJoCo as a null-terminated string.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mj_warning-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mj_warning","text":"mj_warning(d, warning, info)\n\nHigh-level warning function: count warnings in mjData, print only the first.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjd_inverseFD-NTuple{11, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjd_inverseFD","text":"mjd_inverseFD(m, d, eps, flg_actuation, DfDq, DfDv, DfDa, DsDq, DsDv, DsDa, DmDq)\n\nFinite differenced Jacobians of (force, sensors) = mjinverse(state, acceleration)   All outputs are optional. Output dimensions (transposed w.r.t Control Theory convention):     DfDq: (nv x nv)     DfDv: (nv x nv)     DfDa: (nv x nv)     DsDq: (nv x nsensordata)     DsDv: (nv x nsensordata)     DsDa: (nv x nsensordata)     DmDq: (nv x nM)   single-letter shortcuts:     inputs: q=qpos, v=qvel, a=qacc     outputs: f=qfrcinverse, s=sensordata, m=qM   notes:     optionally computes mass matrix Jacobian DmDq     flgactuation specifies whether to subtract qfrcactuator from qfrc_inverse\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjd_quatIntegrate-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjd_quatIntegrate","text":"mjd_quatIntegrate(vel, scale, Dquat, Dvel, Dscale)\n\nDerivatives of mju_quatIntegrate.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjd_subQuat-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjd_subQuat","text":"mjd_subQuat(qa, qb, Da, Db)\n\nDerivatives of mju_subQuat.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjd_transitionFD-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjd_transitionFD","text":"mjd_transitionFD(m, d, eps, flg_centered, A, B, C, D)\n\nFinite differenced transition matrices (control theory notation)   d(x_next) = Adx + Bdu   d(sensor) = Cdx + Ddu   required output matrix dimensions:      A: (2nv+na x 2nv+na)      B: (2nv+na x nu)      D: (nsensordata x 2nv+na)      C: (nsensordata x nu)\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_defaultPlugin-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_defaultPlugin","text":"mjp_defaultPlugin(plugin)\n\nSet default plugin definition.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_defaultResourceProvider-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_defaultResourceProvider","text":"mjp_defaultResourceProvider(provider)\n\nSet default resource provider definition.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_getPlugin-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_getPlugin","text":"mjp_getPlugin(name, slot)\n\nLook up a plugin by name. If slot is not NULL, also write its registered slot number into it.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_getPluginAtSlot-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_getPluginAtSlot","text":"mjp_getPluginAtSlot(slot)\n\nLook up a plugin by the registered slot number that was returned by mjp_registerPlugin.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_getResourceProvider-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_getResourceProvider","text":"mjp_getResourceProvider(resource_name)\n\nReturn the resource provider with the prefix that matches against the resource name. If no match, return NULL.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_getResourceProviderAtSlot-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_getResourceProviderAtSlot","text":"mjp_getResourceProviderAtSlot(slot)\n\nLook up a resource provider by slot number returned by mjp_registerResourceProvider. If invalid slot number, return NULL.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_pluginCount-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_pluginCount","text":"mjp_pluginCount()\n\nReturn the number of globally registered plugins.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_registerPlugin-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_registerPlugin","text":"mjp_registerPlugin(plugin)\n\nGlobally register a plugin. This function is thread-safe. If an identical mjpPlugin is already registered, this function does nothing. If a non-identical mjpPlugin with the same name is already registered, an mju_error is raised. Two mjpPlugins are considered identical if all member function pointers and numbers are equal, and the name and attribute strings are all identical, however the char pointers to the strings need not be the same.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_registerResourceProvider-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_registerResourceProvider","text":"mjp_registerResourceProvider(provider)\n\nGlobally register a resource provider in a thread-safe manner. The provider must have a prefix that is not a sub-prefix or super-prefix of any current registered providers.  This function returns a slot number > 0 on success.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjp_resourceProviderCount-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mjp_resourceProviderCount","text":"mjp_resourceProviderCount()\n\nReturn the number of globally registered resource providers.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_addAux-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_addAux","text":"mjr_addAux(index, width, height, samples, con)\n\nAdd Aux buffer with given index to context; free previous Aux buffer.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_blitAux-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_blitAux","text":"mjr_blitAux(index, src, left, bottom, con)\n\nBlit from Aux buffer to con->currentBuffer.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_blitBuffer-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_blitBuffer","text":"mjr_blitBuffer(src, dst, flg_color, flg_depth, con)\n\nBlit from src viewpoint in current framebuffer to dst viewport in other framebuffer. If src, dst have different size and flgdepth==0, color is interpolated with GLLINEAR.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_changeFont-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_changeFont","text":"mjr_changeFont(fontscale, con)\n\nChange font of existing context.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_defaultContext-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_defaultContext","text":"mjr_defaultContext(con)\n\nSet default mjrContext.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_drawPixels-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_drawPixels","text":"mjr_drawPixels(rgb, depth, viewport, con)\n\nDraw pixels from client buffer to current OpenGL framebuffer. Viewport is in OpenGL framebuffer; client buffer starts at (0,0).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_figure-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_figure","text":"mjr_figure(viewport, fig, con)\n\nDraw 2D figure.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_findRect-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_findRect","text":"mjr_findRect(x, y, nrect, rect)\n\nFind first rectangle containing mouse, -1: not found.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_finish-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_finish","text":"mjr_finish()\n\nCall glFinish.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_freeContext-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_freeContext","text":"mjr_freeContext(con)\n\nFree resources in custom OpenGL context, set to default.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_getError-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_getError","text":"mjr_getError()\n\nCall glGetError and return result.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_label-NTuple{11, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_label","text":"mjr_label(viewport, font, txt, r, g, b, a, rt, gt, bt, con)\n\nDraw rectangle with centered text.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_makeContext-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_makeContext","text":"mjr_makeContext(m, con, fontscale)\n\nAllocate resources in custom OpenGL context; fontscale is mjtFontScale.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_maxViewport-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_maxViewport","text":"mjr_maxViewport(con)\n\nGet maximum viewport for active buffer.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_overlay-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_overlay","text":"mjr_overlay(font, gridpos, viewport, overlay, overlay2, con)\n\nDraw text overlay; font is mjtFont; gridpos is mjtGridPos.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_readPixels-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_readPixels","text":"mjr_readPixels(rgb, depth, viewport, con)\n\nRead pixels from current OpenGL framebuffer to client buffer. Viewport is in OpenGL framebuffer; client buffer starts at (0,0).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_rectangle-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_rectangle","text":"mjr_rectangle(viewport, r, g, b, a)\n\nDraw rectangle.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_render-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_render","text":"mjr_render(viewport, scn, con)\n\nRender 3D scene.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_resizeOffscreen-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_resizeOffscreen","text":"mjr_resizeOffscreen(width, height, con)\n\nResize offscreen buffers.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_restoreBuffer-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_restoreBuffer","text":"mjr_restoreBuffer(con)\n\nMake con->currentBuffer current again.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_setAux-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_setAux","text":"mjr_setAux(index, con)\n\nSet Aux buffer for custom OpenGL rendering (call restoreBuffer when done).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_setBuffer-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_setBuffer","text":"mjr_setBuffer(framebuffer, con)\n\nSet OpenGL framebuffer for rendering: mjFBWINDOW or mjFBOFFSCREEN. If only one buffer is available, set that buffer and ignore framebuffer argument.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_text-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_text","text":"mjr_text(font, txt, con, x, y, r, g, b)\n\nDraw text at (x,y) in relative coordinates; font is mjtFont.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_uploadHField-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_uploadHField","text":"mjr_uploadHField(m, con, hfieldid)\n\nUpload height field to GPU, overwriting previous upload if any.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_uploadMesh-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_uploadMesh","text":"mjr_uploadMesh(m, con, meshid)\n\nUpload mesh to GPU, overwriting previous upload if any.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjr_uploadTexture-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjr_uploadTexture","text":"mjr_uploadTexture(m, con, texid)\n\nUpload texture to GPU, overwriting previous upload if any.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_Halton-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_Halton","text":"mju_Halton(index, base)\n\nGenerate Halton sequence.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_L1-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_L1","text":"mju_L1(vec, n)\n\nReturn L1 norm: sum(abs(vec)).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_add-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_add","text":"mju_add(res, vec1, vec2, n)\n\nSet res = vec1 + vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_add3-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_add3","text":"mju_add3(res, vec1, vec2)\n\nSet res = vec1 + vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addScl-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addScl","text":"mju_addScl(res, vec1, vec2, scl, n)\n\nSet res = vec1 + vec2*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addScl3-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addScl3","text":"mju_addScl3(res, vec1, vec2, scl)\n\nSet res = vec1 + vec2*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addTo-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addTo","text":"mju_addTo(res, vec, n)\n\nSet res = res + vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addTo3-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addTo3","text":"mju_addTo3(res, vec)\n\nSet res = res + vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addToScl-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addToScl","text":"mju_addToScl(res, vec, scl, n)\n\nSet res = res + vec*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_addToScl3-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_addToScl3","text":"mju_addToScl3(res, vec, scl)\n\nSet res = res + vec*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_axisAngle2Quat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_axisAngle2Quat","text":"mju_axisAngle2Quat(res, axis, angle)\n\nConvert axisAngle to quaternion.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_band2Dense-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_band2Dense","text":"mju_band2Dense(res, mat, ntotal, nband, ndense, flg_sym)\n\nConvert banded matrix to dense matrix, fill upper triangle if flg_sym>0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_bandDiag-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_bandDiag","text":"mju_bandDiag(i, ntotal, nband, ndense)\n\nAddress of diagonal element i in band-dense matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_bandMulMatVec-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_bandMulMatVec","text":"mju_bandMulMatVec(res, mat, vec, ntotal, nband, ndense, nvec, flg_sym)\n\nMultiply band-diagonal matrix with nvec vectors, include upper triangle if flg_sym>0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_boxQP-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_boxQP","text":"mju_boxQP(res, R, index, H, g, n, lower, upper)\n\nminimize 0.5x'Hx + x'g  s.t. lower <= x <= upper, return rank or -1 if failed   inputs:     n           - problem dimension     H           - SPD matrix                nn     g           - bias vector               n     lower       - lower bounds              n     upper       - upper bounds              n     res         - solution warmstart        n   return value:     nfree <= n  - rank of unconstrained subspace, -1 if failure   outputs (required):     res         - solution                  n     R           - subspace Cholesky factor  nfreenfree    allocated: n(n+7)   outputs (optional):     index       - set of free dimensions    nfree          allocated: n   notes:     the initial value of res is used to warmstart the solver     R must have allocatd size n(n+7), but only nfree*nfree values are used in output     index (if given) must have allocated size n, but only nfree values are used in output     only the lower triangles of H and R and are read from and written to, respectively     the convenience function mju_boxQPmalloc allocates the required data structures\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_boxQPmalloc-NTuple{8, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_boxQPmalloc","text":"mju_boxQPmalloc(res, R, index, H, g, n, lower, upper)\n\nallocate heap memory for box-constrained Quadratic Program   as in mjuboxQP, index, lower, and upper are optional   free all pointers with mjufree()\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cholFactor-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cholFactor","text":"mju_cholFactor(mat, n, mindiag)\n\nCholesky decomposition: mat = L*L'; return rank, decomposition performed in-place into mat.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cholFactorBand-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cholFactorBand","text":"mju_cholFactorBand(mat, ntotal, nband, ndense, diagadd, diagmul)\n\nBand-dense Cholesky decomposition.  Returns minimum value in the factorized diagonal, or 0 if rank-deficient.  mat has (ntotal-ndense) x nband + ndense x ntotal elements.  The first (ntotal-ndense) x nband store the band part, left of diagonal, inclusive.  The second ndense x ntotal store the band part as entire dense rows.  Add diagadd+diagmul*mat_ii to diagonal before factorization.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cholSolve-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cholSolve","text":"mju_cholSolve(res, mat, vec, n)\n\nSolve (mat*mat') * res = vec, where mat is a Cholesky factor.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cholSolveBand-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cholSolveBand","text":"mju_cholSolveBand(res, mat, vec, ntotal, nband, ndense)\n\nSolve (matmat')res = vec where mat is a band-dense Cholesky factor.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cholUpdate-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cholUpdate","text":"mju_cholUpdate(mat, x, n, flg_plus)\n\nCholesky rank-one update: LL' +/- xx'; return rank.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_clearHandlers-Tuple{}","page":"API","title":"MuJoCo.LibMuJoCo.mju_clearHandlers","text":"mju_clearHandlers()\n\nClear user error and memory handlers.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_clip-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_clip","text":"mju_clip(x, min, max)\n\nClip x to the range [min, max].\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_copy-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_copy","text":"mju_copy(res, data, n)\n\nSet res = vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_copy3-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_copy3","text":"mju_copy3(res, data)\n\nSet res = vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_copy4-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_copy4","text":"mju_copy4(res, data)\n\nSet res = vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_cross-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_cross","text":"mju_cross(res, a, b)\n\nCompute cross-product: res = cross(a, b).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_d2n-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_d2n","text":"mju_d2n(res, vec, n)\n\nConvert from double to mjtNum.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_decodePyramid-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_decodePyramid","text":"mju_decodePyramid(force, pyramid, mu, dim)\n\nConvert pyramid representation to contact force.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_dense2Band-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_dense2Band","text":"mju_dense2Band(res, mat, ntotal, nband, ndense)\n\nConvert dense matrix to banded matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_derivQuat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_derivQuat","text":"mju_derivQuat(res, quat, vel)\n\nCompute time-derivative of quaternion, given 3D rotational velocity.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_dist3-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_dist3","text":"mju_dist3(pos1, pos2)\n\nReturn Cartesian distance between 3D vectors pos1 and pos2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_dot-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_dot","text":"mju_dot(vec1, vec2, n)\n\nReturn dot-product of vec1 and vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_dot3-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_dot3","text":"mju_dot3(vec1, vec2)\n\nReturn dot-product of vec1 and vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_eig3-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_eig3","text":"mju_eig3(eigval, eigvec, quat, mat)\n\nEigenvalue decomposition of symmetric 3x3 matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_encodePyramid-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_encodePyramid","text":"mju_encodePyramid(pyramid, force, mu, dim)\n\nConvert contact force to pyramid representation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_error_i-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_error_i","text":"mju_error_i(msg, i)\n\nDeprecated: use mju_error.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_error_s-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_error_s","text":"mju_error_s(msg, text)\n\nDeprecated: use mju_error.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_eye-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_eye","text":"mju_eye(mat, n)\n\nSet mat to the identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_f2n-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_f2n","text":"mju_f2n(res, vec, n)\n\nConvert from float to mjtNum.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_fill-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_fill","text":"mju_fill(res, val, n)\n\nSet res = val.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_free-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_free","text":"mju_free(ptr)\n\nFree memory, using free() by default.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_insertionSort-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_insertionSort","text":"mju_insertionSort(list, n)\n\nInsertion sort, resulting list is in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_insertionSortInt-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_insertionSortInt","text":"mju_insertionSortInt(list, n)\n\nInteger insertion sort, resulting list is in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_isBad-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_isBad","text":"mju_isBad(x)\n\nReturn 1 if nan or abs(x)>mjMAXVAL, 0 otherwise. Used by check functions.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_isZero-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_isZero","text":"mju_isZero(vec, n)\n\nReturn 1 if all elements are 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_malloc-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_malloc","text":"mju_malloc(size)\n\nAllocate memory; byte-align on 64; pad size to multiple of 64.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mat2Quat-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mat2Quat","text":"mju_mat2Quat(quat, mat)\n\nConvert 3D rotation matrix to quaternion.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_max-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_max","text":"mju_max(a, b)\n\nReturn max(a,b) with single evaluation of a and b.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_min-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_min","text":"mju_min(a, b)\n\nReturn min(a,b) with single evaluation of a and b.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulMatMat-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulMatMat","text":"mju_mulMatMat(res, mat1, mat2, r1, c1, c2)\n\nMultiply matrices: res = mat1 * mat2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulMatMatT-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulMatMatT","text":"mju_mulMatMatT(res, mat1, mat2, r1, c1, r2)\n\nMultiply matrices, second argument transposed: res = mat1 * mat2'.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulMatTMat-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulMatTMat","text":"mju_mulMatTMat(res, mat1, mat2, r1, c1, c2)\n\nMultiply matrices, first argument transposed: res = mat1' * mat2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulMatTVec-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulMatTVec","text":"mju_mulMatTVec(res, mat, vec, nr, nc)\n\nMultiply transposed matrix and vector: res = mat' * vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulMatVec-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulMatVec","text":"mju_mulMatVec(res, mat, vec, nr, nc)\n\nMultiply matrix and vector: res = mat * vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulPose-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulPose","text":"mju_mulPose(posres, quatres, pos1, quat1, pos2, quat2)\n\nMultiply two poses.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulQuat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulQuat","text":"mju_mulQuat(res, quat1, quat2)\n\nMultiply quaternions.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulQuatAxis-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulQuatAxis","text":"mju_mulQuatAxis(res, quat, axis)\n\nMultiply quaternion and axis.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_mulVecMatVec-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_mulVecMatVec","text":"mju_mulVecMatVec(vec1, mat, vec2, n)\n\nMultiply square matrix with vectors on both sides: returns vec1' * mat * vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_muscleBias-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_muscleBias","text":"mju_muscleBias(len, lengthrange, acc0, prm)\n\nMuscle passive force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_muscleDynamics-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_muscleDynamics","text":"mju_muscleDynamics(ctrl, act, prm)\n\nMuscle activation dynamics, prm = (tauact, taudeact, smoothing_width).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_muscleGain-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_muscleGain","text":"mju_muscleGain(len, vel, lengthrange, acc0, prm)\n\nMuscle active force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_n2d-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_n2d","text":"mju_n2d(res, vec, n)\n\nConvert from mjtNum to double.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_n2f-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_n2f","text":"mju_n2f(res, vec, n)\n\nConvert from mjtNum to float.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_negPose-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_negPose","text":"mju_negPose(posres, quatres, pos, quat)\n\nConjugate pose, corresponding to the opposite spatial transformation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_negQuat-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_negQuat","text":"mju_negQuat(res, quat)\n\nConjugate quaternion, corresponding to opposite rotation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_norm-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_norm","text":"mju_norm(res, n)\n\nReturn vector length (without normalizing vector).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_norm3-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_norm3","text":"mju_norm3(vec)\n\nReturn vector length (without normalizing the vector).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_normalize-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_normalize","text":"mju_normalize(res, n)\n\nNormalize vector, return length before normalization.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_normalize3-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_normalize3","text":"mju_normalize3(res)\n\nNormalize vector, return length before normalization.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_normalize4-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_normalize4","text":"mju_normalize4(res)\n\nNormalize vector, return length before normalization.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_printMat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_printMat","text":"mju_printMat(mat, nr, nc)\n\nPrint matrix to screen.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_printMatSparse-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_printMatSparse","text":"mju_printMatSparse(mat, nr, rownnz, rowadr, colind)\n\nPrint sparse matrix to screen.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_quat2Mat-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_quat2Mat","text":"mju_quat2Mat(res, quat)\n\nConvert quaternion to 3D rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_quat2Vel-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_quat2Vel","text":"mju_quat2Vel(res, quat, dt)\n\nConvert quaternion (corresponding to orientation difference) to 3D velocity.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_quatIntegrate-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_quatIntegrate","text":"mju_quatIntegrate(quat, vel, scale)\n\nIntegrate quaternion given 3D angular velocity.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_quatZ2Vec-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_quatZ2Vec","text":"mju_quatZ2Vec(quat, vec)\n\nConstruct quaternion performing rotation from z-axis to given vector.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_rayGeom-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_rayGeom","text":"mju_rayGeom(pos, mat, size, pnt, vec, geomtype)\n\nIntersect ray with pure geom, return nearest distance or -1 if no intersection.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_raySkin-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_raySkin","text":"mju_raySkin(nface, nvert, face, vert, pnt, vec, vertid)\n\nIntersect ray with skin, return nearest distance or -1 if no intersection, and also output nearest vertex id.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_rotVecMat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_rotVecMat","text":"mju_rotVecMat(res, vec, mat)\n\nMultiply vector by 3D rotation matrix: res = mat * vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_rotVecMatT-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_rotVecMatT","text":"mju_rotVecMatT(res, vec, mat)\n\nMultiply vector by transposed 3D rotation matrix: res = mat' * vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_rotVecQuat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_rotVecQuat","text":"mju_rotVecQuat(res, vec, quat)\n\nRotate vector by quaternion.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_round-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_round","text":"mju_round(x)\n\nRound x to nearest integer.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_scl-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_scl","text":"mju_scl(res, vec, scl, n)\n\nSet res = vec*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_scl3-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_scl3","text":"mju_scl3(res, vec, scl)\n\nSet res = vec*scl.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sigmoid-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sigmoid","text":"mju_sigmoid(x)\n\nSigmoid function over 0<=x<=1 using quintic polynomial.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sign-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sign","text":"mju_sign(x)\n\nReturn sign of x: +1, -1 or 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_springDamper-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_springDamper","text":"mju_springDamper(pos0, vel0, Kp, Kv, dt)\n\nIntegrate spring-damper analytically, return pos(dt).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sqrMatTD-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sqrMatTD","text":"mju_sqrMatTD(res, mat, diag, nr, nc)\n\nSet res = mat' * diag * mat if diag is not NULL, and res = mat' * mat otherwise.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_standardNormal-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_standardNormal","text":"mju_standardNormal(num2)\n\nStandard normal random number generator (optional second number).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_str2Type-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_str2Type","text":"mju_str2Type(str)\n\nConvert type name to type id (mjtObj).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_strncpy-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_strncpy","text":"mju_strncpy(dst, src, n)\n\nCall strncpy, then set dst[n-1] = 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sub-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sub","text":"mju_sub(res, vec1, vec2, n)\n\nSet res = vec1 - vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sub3-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sub3","text":"mju_sub3(res, vec1, vec2)\n\nSet res = vec1 - vec2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_subFrom-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_subFrom","text":"mju_subFrom(res, vec, n)\n\nSet res = res - vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_subFrom3-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_subFrom3","text":"mju_subFrom3(res, vec)\n\nSet res = res - vec.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_subQuat-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_subQuat","text":"mju_subQuat(res, qa, qb)\n\nSubtract quaternions, express as 3D velocity: qb*quat(res) = qa.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_sum-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_sum","text":"mju_sum(vec, n)\n\nReturn sum(vec).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_symmetrize-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_symmetrize","text":"mju_symmetrize(res, mat, n)\n\nSymmetrize square matrix res = (mat + mat')/2.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_transformSpatial-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_transformSpatial","text":"mju_transformSpatial(res, vec, flg_force, newpos, oldpos, rotnew2old)\n\nCoordinate transform of 6D motion or force vector in rotation:translation format. rotnew2old is 3-by-3, NULL means no rotation; flg_force specifies force or motion type.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_transpose-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_transpose","text":"mju_transpose(res, mat, nr, nc)\n\nTranspose matrix: res = mat'.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_trnVecPose-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_trnVecPose","text":"mju_trnVecPose(res, pos, quat, vec)\n\nTransform vector by pose.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_type2Str-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_type2Str","text":"mju_type2Str(type)\n\nConvert type id (mjtObj) to type name.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_unit4-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_unit4","text":"mju_unit4(res)\n\nSet res = (1,0,0,0).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_warningText-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_warningText","text":"mju_warningText(warning, info)\n\nConstruct a warning message given the warning type and info.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_warning_i-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_warning_i","text":"mju_warning_i(msg, i)\n\nDeprecated: use mju_warning.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_warning_s-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_warning_s","text":"mju_warning_s(msg, text)\n\nDeprecated: use mju_warning.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_writeLog-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_writeLog","text":"mju_writeLog(type, msg)\n\nWrite [datetime, type: message] to MUJOCO_LOG.TXT.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_writeNumBytes-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_writeNumBytes","text":"mju_writeNumBytes(nbytes)\n\nReturn human readable number of bytes using standard letter suffix.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_zero-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_zero","text":"mju_zero(res, n)\n\nSet res = 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_zero3-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_zero3","text":"mju_zero3(res)\n\nSet res = 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mju_zero4-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mju_zero4","text":"mju_zero4(res)\n\nSet res = 0.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_add-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_add","text":"mjui_add(ui, def)\n\nAdd definitions to UI.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_addToSection-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_addToSection","text":"mjui_addToSection(ui, sect, def)\n\nAdd definitions to UI section.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_event-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_event","text":"mjui_event(ui, state, con)\n\nHandle UI event, return pointer to changed item, NULL if no change.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_render-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_render","text":"mjui_render(ui, state, con)\n\nCopy UI image to current buffer.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_resize-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_resize","text":"mjui_resize(ui, con)\n\nCompute UI sizes.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_themeColor-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_themeColor","text":"mjui_themeColor(ind)\n\nGet builtin UI theme color (ind: 0-3).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_themeSpacing-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_themeSpacing","text":"mjui_themeSpacing(ind)\n\nGet builtin UI theme spacing (ind: 0-1).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjui_update-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjui_update","text":"mjui_update(section, item, ui, state, con)\n\nUpdate specific section/item; -1: update all.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_addGeoms-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_addGeoms","text":"mjv_addGeoms(m, d, opt, pert, catmask, scn)\n\nAdd geoms from selected categories.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_alignToCamera-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_alignToCamera","text":"mjv_alignToCamera(res, vec, forward)\n\nRotate 3D vec in horizontal plane by angle between (0,1) and (forwardx,forwardy).\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_applyPerturbForce-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_applyPerturbForce","text":"mjv_applyPerturbForce(m, d, pert)\n\nSet perturb force,torque in d->xfrc_applied, if selected body is dynamic.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_applyPerturbPose-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_applyPerturbPose","text":"mjv_applyPerturbPose(m, d, pert, flg_paused)\n\nSet perturb pos,quat in d->mocap when selected body is mocap, and in d->qpos otherwise. Write d->qpos only if flg_paused and subtree root for selected body has free joint.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_averageCamera-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_averageCamera","text":"mjv_averageCamera(cam1, cam2)\n\nReturn the average of two OpenGL cameras.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_cameraInModel-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_cameraInModel","text":"mjv_cameraInModel(headpos, forward, up, scn)\n\nGet camera info in model space; average left and right OpenGL cameras.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_cameraInRoom-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_cameraInRoom","text":"mjv_cameraInRoom(headpos, forward, up, scn)\n\nGet camera info in room space; average left and right OpenGL cameras.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_connector-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_connector","text":"mjv_connector(geom, type, width, from, to)\n\nSet (type, size, pos, mat) for connector-type geom between given points. Assume that mjvinitGeom was already called to set all other properties. Width of mjGEOMLINE is denominated in pixels.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultCamera-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultCamera","text":"mjv_defaultCamera(cam)\n\nSet default camera.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultFigure-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultFigure","text":"mjv_defaultFigure(fig)\n\nSet default figure.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultFreeCamera-Tuple{Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultFreeCamera","text":"mjv_defaultFreeCamera(m, cam)\n\nSet default free camera.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultOption-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultOption","text":"mjv_defaultOption(opt)\n\nSet default visualization options.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultPerturb-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultPerturb","text":"mjv_defaultPerturb(pert)\n\nSet default perturbation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultScene-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultScene","text":"mjv_defaultScene(scn)\n\nSet default abstract scene.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_defaultSceneState-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_defaultSceneState","text":"mjv_defaultSceneState(scnstate)\n\nSet default scene state.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_freeScene-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_freeScene","text":"mjv_freeScene(scn)\n\nFree abstract scene.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_freeSceneState-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_freeSceneState","text":"mjv_freeSceneState(scnstate)\n\nFree scene state.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_frustumHeight-Tuple{Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_frustumHeight","text":"mjv_frustumHeight(scn)\n\nGet frustum height at unit distance from camera; average left and right OpenGL cameras.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_initGeom-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_initGeom","text":"mjv_initGeom(geom, type, size, pos, mat, rgba)\n\nInitialize given geom fields when not NULL, set the rest to their default values.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_initPerturb-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_initPerturb","text":"mjv_initPerturb(m, d, scn, pert)\n\nCopy perturb pos,quat from selected body; set scale for perturbation.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_makeConnector-NTuple{9, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_makeConnector","text":"mjv_makeConnector(geom, type, width, a0, a1, a2, b0, b1, b2)\n\nSet (type, size, pos, mat) for connector-type geom between given points. Assume that mjvinitGeom was already called to set all other properties. Width of mjGEOMLINE is denominated in pixels. Deprecated: use mjv_connector.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_makeLights-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_makeLights","text":"mjv_makeLights(m, d, scn)\n\nMake list of lights.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_makeScene-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_makeScene","text":"mjv_makeScene(m, scn, maxgeom)\n\nAllocate resources in abstract scene.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_makeSceneState-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_makeSceneState","text":"mjv_makeSceneState(m, d, scnstate, maxgeom)\n\nAllocate resources and initialize a scene state object.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_model2room-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_model2room","text":"mjv_model2room(roompos, roomquat, modelpos, modelquat, scn)\n\nTransform pose from model to room space.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_moveCamera-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_moveCamera","text":"mjv_moveCamera(m, action, reldx, reldy, scn, cam)\n\nMove camera with mouse; action is mjtMouse.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_moveCameraFromState-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_moveCameraFromState","text":"mjv_moveCameraFromState(scnstate, action, reldx, reldy, scn, cam)\n\nMove camera with mouse given a scene state; action is mjtMouse.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_moveModel-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_moveModel","text":"mjv_moveModel(m, action, reldx, reldy, roomup, scn)\n\nMove model with mouse; action is mjtMouse.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_movePerturb-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_movePerturb","text":"mjv_movePerturb(m, d, action, reldx, reldy, scn, pert)\n\nMove perturb object with mouse; action is mjtMouse.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_movePerturbFromState-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_movePerturbFromState","text":"mjv_movePerturbFromState(scnstate, action, reldx, reldy, scn, pert)\n\nMove perturb object with mouse given a scene state; action is mjtMouse.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_room2model-NTuple{5, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_room2model","text":"mjv_room2model(modelpos, modelquat, roompos, roomquat, scn)\n\nTransform pose from room to model space.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_select-NTuple{10, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_select","text":"mjv_select(m, d, vopt, aspectratio, relx, rely, scn, selpnt, geomid, skinid)\n\nSelect geom or skin with mouse, return bodyid; -1: none selected.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_updateCamera-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_updateCamera","text":"mjv_updateCamera(m, d, cam, scn)\n\nUpdate camera.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_updateScene-NTuple{7, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_updateScene","text":"mjv_updateScene(m, d, opt, pert, cam, catmask, scn)\n\nUpdate entire scene given model state.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_updateSceneFromState-NTuple{6, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_updateSceneFromState","text":"mjv_updateSceneFromState(scnstate, opt, pert, cam, catmask, scn)\n\nUpdate entire scene from a scene state, return the number of new mjWARN_VGEOMFULL warnings.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_updateSceneState-NTuple{4, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_updateSceneState","text":"mjv_updateSceneState(m, d, opt, scnstate)\n\nUpdate a scene state from model and data.\n\n\n\n\n\n","category":"method"},{"location":"library/libmujoco/#MuJoCo.LibMuJoCo.mjv_updateSkin-Tuple{Any, Any, Any}","page":"API","title":"MuJoCo.LibMuJoCo.mjv_updateSkin","text":"mjv_updateSkin(m, d, scn)\n\nUpdate skins.\n\n\n\n\n\n","category":"method"}]
}
