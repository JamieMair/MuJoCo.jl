<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Balancing a Cart-Pole · MuJoCo.jl</title><meta name="title" content="Balancing a Cart-Pole · MuJoCo.jl"/><meta property="og:title" content="Balancing a Cart-Pole · MuJoCo.jl"/><meta property="twitter:title" content="Balancing a Cart-Pole · MuJoCo.jl"/><meta name="description" content="Documentation for MuJoCo.jl."/><meta property="og:description" content="Documentation for MuJoCo.jl."/><meta property="twitter:description" content="Documentation for MuJoCo.jl."/><meta property="og:url" content="https://JamieMair.github.io/MuJoCo.jl/examples/cartpole_balance/"/><meta property="twitter:url" content="https://JamieMair.github.io/MuJoCo.jl/examples/cartpole_balance/"/><link rel="canonical" href="https://JamieMair.github.io/MuJoCo.jl/examples/cartpole_balance/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MuJoCo.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MuJoCo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../../intro/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../intro/overview/">Package Overview</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Balancing a Cart-Pole</a><ul class="internal"><li><a class="tocitem" href="#Loading-a-model"><span>Loading a model</span></a></li><li><a class="tocitem" href="#A-quick-review-of-LQR"><span>A quick review of LQR</span></a></li><li><a class="tocitem" href="#Linearising-the-dynamics"><span>Linearising the dynamics</span></a></li><li><a class="tocitem" href="#Designing-a-controller"><span>Designing a controller</span></a></li><li><a class="tocitem" href="#Simulate-and-visualise"><span>Simulate and visualise</span></a></li></ul></li><li><a class="tocitem" href="../humanoid_lqr/">Humanoid LQR</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../contributing/developing/">Contributing to the Package</a></li></ul></li><li><a class="tocitem" href="../../library/api/">API</a></li><li><span class="tocitem">C Bindings</span><ul><li><a class="tocitem" href="../../library/libmujoco/">API</a></li><li><a class="tocitem" href="../../library/libmujoco_index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Balancing a Cart-Pole</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Balancing a Cart-Pole</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JamieMair/MuJoCo.jl/blob/{commit}{path}#{line}" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JamieMair/MuJoCo.jl/blob/main/docs/src/examples/cartpole_balance.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Balancing-a-Cart-Pole"><a class="docs-heading-anchor" href="#Balancing-a-Cart-Pole">Balancing a Cart-Pole</a><a id="Balancing-a-Cart-Pole-1"></a><a class="docs-heading-anchor-permalink" href="#Balancing-a-Cart-Pole" title="Permalink"></a></h1><p>For our first example, we&#39;ll simulate a cart-pole system balancing its pendulum in the upright equilibrium using a <a href="https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator"><em>Linear Quadratic Regulator</em> (LQR)</a>. Simulating controllers which balance and stabilise robotic systems is a common use-case for MuJoCo, so this is a good starting point. There are plenty of different ways to design stabilising controllers for the cart-pole system (eg: <a href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller">PID</a>, <a href="https://en.wikipedia.org/wiki/Model_predictive_control">MPC</a>, <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">reinforcement learning</a>, etc...). Feel free to extend this example with your own controllers and play around with it!</p><h2 id="Loading-a-model"><a class="docs-heading-anchor" href="#Loading-a-model">Loading a model</a><a id="Loading-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-a-model" title="Permalink"></a></h2><p>Our first step is to load a MuJoCo model of the cart-pole system. You can find a copy of the standard <code>cartpole.xml</code> file used by DeepMind <a href="https://github.com/JamieMair/MuJoCo.jl/blob/42ec7971be584e3f87aacae40e50f8d43a2dc29c/docs/src/examples/cartpole.xml">here</a>. </p><pre><code class="language-julia hljs">using MuJoCo

model = load_model(&quot;cartpole.xml&quot;)
data = init_data(model)

println(&quot;Initial position: &quot;, data.qpos)
println(&quot;Initial velocity: &quot;, data.qvel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Initial position: [0.0; 0.0;;]
Initial velocity: [0.0; 0.0;;]</code></pre><p>The system starts off with zero velocity, at the origin (<code>data.qpos[1] == 0</code>) and with the pendulum perfectly upright (<code>data.qpos[1] == 0</code>). This is the state we&#39;ll want to keep it in with our controller.</p><h2 id="A-quick-review-of-LQR"><a class="docs-heading-anchor" href="#A-quick-review-of-LQR">A quick review of LQR</a><a id="A-quick-review-of-LQR-1"></a><a class="docs-heading-anchor-permalink" href="#A-quick-review-of-LQR" title="Permalink"></a></h2><p>There are many textbooks, tutorials, and course notes describing LQRs in considerable depth (see <a href="http://underactuated.mit.edu/lqr.html#section3">here</a> for an example). We&#39;ll give a brief, high-level recap here. Suppose you have a system with state vector <span>$x$</span> (eg: joint positions and velocities) and some control inputs <span>$u$</span> (eg: forces and/or torques). We often write the system dynamics as <span>$x_{t+1} = f(x_t, u_t)$</span>, where the function <span>$f$</span> describes how the states <span>$x$</span> evolve at each time-step <span>$t$</span>.</p><p>In linear control design, our job is often to figure out what the control inputs <span>$u_t$</span> should be to keep the system at some desired set-point <span>$(x^*, u^*)$</span>. For our cart-pole, we want it to be stationary and upright at the origin, so <span>$(x^*, u^*) = ($</span><code>zeros(4)</code><span>$, 0)$</span>. Let&#39;s look at a linear approximation of the system about this set-point:</p><p class="math-container">\[\delta x_{t+1} = A \delta x_t + B \delta u_t\]</p><p>Here, we&#39;ve defined <span>$\delta x_t = x_t - x^*$</span> and <span>$\delta u_t = u_t - u^*$</span> as the differences between the current and desired states and controls (respectively). The matrices <span>$A,B$</span> defining the linear model are the Jacobians</p><p class="math-container">\[A = \frac{\partial f}{\partial x} \quad B = \frac{\partial f}{\partial u}.\]</p><p>Our task is to design a controller that will keep <span>$\delta x_t$</span> and <span>$\delta u_t$</span> small. In particular, we can define a cost-function that we want our controller to optimise. For an LQR, we define a quadratic cost</p><p class="math-container">\[J(\delta x_t, \delta u_t) = \delta x_t^\top Q \delta x_t + \delta u_t^\top R \delta u_t\]</p><p>to be minimised, where <span>$Q,R$</span> are positive-definite matrices of our choosing. With a little bit of matrix algebra and vector calculus based on the <a href="https://en.wikipedia.org/wiki/Bellman_equation">Bellman equation</a>, it turns out that the optimal control law is <span>$u_t = -K x_t$</span> where </p><p class="math-container">\[K = (R + B^\top P B)^{-1} B^\top P A\\
P = A^\top P A + Q - A^\top P B (R + B^\top P B)^{-1} B^\top P A.\]</p><p>Thankfully, this last equation is a well-studied <a href="https://en.wikipedia.org/wiki/Riccati_equation">Riccati equation</a>, so we can use packages like <a href="https://github.com/andreasvarga/MatrixEquations.jl"><code>MatrixEquations.jl</code></a> or <a href="https://github.com/JuliaControl/ControlSystems.jl"><code>ControlSystems.jl</code></a> to solve it for us.</p><h2 id="Linearising-the-dynamics"><a class="docs-heading-anchor" href="#Linearising-the-dynamics">Linearising the dynamics</a><a id="Linearising-the-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Linearising-the-dynamics" title="Permalink"></a></h2><p>We can use the underlying C API for MuJoCo to easily linearise the dynamics for our cart-pole system. The function <a href="https://mujoco.readthedocs.io/en/stable/APIreference/APIfunctions.html#mjd-transitionfd"><code>mjd_transitionFD</code></a> numerically computes the <span>$A$</span> and <span>$B$</span> matrices with a finite difference method through the MuJoCo simulator.</p><pre><code class="language-julia hljs"># Number of states and controlled inputs
nx = 2*model.nv
nu = model.nu

# Finite-difference parameters
ϵ = 1e-6
centred = true

# Compute the Jacobians
A = mj_zeros(nx, nx)
B = mj_zeros(nx, nu)
mjd_transitionFD(model, data, ϵ, centred, A, B, nothing, nothing)
@show A, B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A, B) = ([1.0 -0.00020933539434596422 0.00999696728367769 7.112993351890879e-6; 0.0 1.0027918363759287 7.112993351890878e-6 0.009905136378663615; 0.0 -0.020933539434596422 0.9996967283677689 0.000711299335189088; 0.0 0.2791836375928739 0.0007112993351890878 0.9905136378663615], [0.0030327163223112376; -0.007112993351890878; 0.30327163223112374; -0.7112993351890878;;])</code></pre><p>Note the use of <a href="../../library/api/#MuJoCo.mj_zeros-Tuple{DataType, Vararg{Any}}"><code>mj_zeros</code></a> to initialise <span>$A,B$</span>. See <a href="../../intro/overview/#Row-vs.-Column-Major-Arrays">Row vs. Column-Major Arrays</a> for more details.</p><h2 id="Designing-a-controller"><a class="docs-heading-anchor" href="#Designing-a-controller">Designing a controller</a><a id="Designing-a-controller-1"></a><a class="docs-heading-anchor-permalink" href="#Designing-a-controller" title="Permalink"></a></h2><p>Now that we have our linear model, all we need to do is compute our LQR gain matrix <span>$K$</span> based on some cost-function with weights <span>$Q,R$</span>. The state vector for our cart-pole system is <code>x = [cart_position, pole_angle, cart_velocity, pole_velocity]</code>. We&#39;ll choose <span>$Q,R$</span> to heavily penalise any movement of the pole away from vertical. This may mean the cart slides around a little bit, but if our goal is to keep the pole upright this is fine.</p><pre><code class="language-julia hljs">using LinearAlgebra

Q = diagm([1, 10, 1, 5]) # Weights for the state vector
R = diagm([1])           # Weights for the controls</code></pre><p>To compute <span>$K$</span>, we could directly use the <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous,%20Type{Continuous}},%20Any,%20Any,%20Any,%20Any,%20Vararg{Any}}"><code>lqr</code></a> function provided in <code>ControlSystemsBase.jl</code> with <code>K = lqr(A,B,Q,R)</code>. For those who don&#39;t want to load the rather large control systems package, we can directly use <a href="https://andreasvarga.github.io/MatrixEquations.jl/dev/riccati.html#MatrixEquations.ared"><code>ared</code></a> from <code>MatrixEquations.jl</code>, which is what <code>lqr</code> calls under the hood.</p><pre><code class="language-julia hljs">using MatrixEquations

S = zeros(nx, nu)
_, _, K, _ = ared(A,B,R,Q,S)
@show K</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×4 Matrix{Float64}:
 -0.467417  -5.59272  -0.843668  -1.44487</code></pre><h2 id="Simulate-and-visualise"><a class="docs-heading-anchor" href="#Simulate-and-visualise">Simulate and visualise</a><a id="Simulate-and-visualise-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-and-visualise" title="Permalink"></a></h2><p>After all that, we now have a stabilising controller for our cart-pole system! Let&#39;s test it out with the visualiser. First, we&#39;ll need a <code>controller</code> function that takes in the MuJoCo <code>model</code> and <code>data</code> structs and sets the control variables.</p><pre><code class="language-julia hljs">function lqr_balance!(m::Model, d::Data)
    state = vcat(d.qpos, d.qvel)
    d.ctrl .= -K * state
    nothing
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Performance Tip</header><div class="admonition-body"><p>This function captures non-const global variables and will take a performance hit (see <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-untyped-global-variables">Performance Tips</a>) for more details. To remedy the performance hit, one can use functors instead, as described at the end of the <a href="../humanoid_lqr/#Humanoid-LQR">Humanoid LQR</a> example.</p></div></div><p>Now we can visualise the model and see how it goes.</p><pre><code class="language-julia hljs">init_visualiser()
visualise!(model, data; controller=lqr_balance!)</code></pre><p><img src="../images/cartpole_balance.gif" alt/></p><p>When we apply small forces to the pole or the cart, the controller immediately responds to the perturbation and returns the system to its equilibrium position. If the force is big enough, the system will become unstable and the pole will fall down. Feel free to play around with the weights in <span>$Q,R$</span> to see their effect on the system too!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../intro/overview/">« Package Overview</a><a class="docs-footer-nextpage" href="../humanoid_lqr/">Humanoid LQR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Thursday 30 November 2023 22:51">Thursday 30 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
